
<html>
	<head>
		<script>
			let questionTime = 36;
			let numberOfQuestions = 5;
		</script>

		<style>
			@import url(https://fonts.googleapis.com/css?family=Work+Sans:300,600);
			body{
				font-size: 20px;
				font-family: 'Work Sans', sans-serif;
				color: #333;
				font-weight: 300;
				text-align: center;
				background-color: #fff;
			}
			h1{
				font-weight: 300;
				margin: 0px;
				padding: 10px;
				font-size: 20px;
				background-color: #444;
				color: #fff;
			}
			.question{
				font-size: 30px;
				margin-bottom: 10px;
			}
			.answers{
				font-size: 20px;
				margin-bottom: 20px;
				text-align: left;
				display: inline-block;
			}
			.answers label{
				font-weight: 500;
				display: block;
				margin-bottom: 10px;
			}
			button{
				font-family: 'Work Sans', sans-serif;
				font-size: 22px;
				background-color: #26529c;
				color: #fff;
				border: 0px;
				border-radius: 15px;
				padding: 20px;
				cursor: pointer;
				margin-bottom: 20px;
			}
			button:hover{
				background-color: #6787ba;
			}
			.slide{
				position: absolute;
				left: 0px;
				top: 0px;
				width: 100%;
				z-index: 1;
				opacity: 0;
				transition: opacity 0.5s;
			}
			.active-slide{
				opacity: 1;
				z-index: 2;
			}
			.quiz-container{
				position: relative;
				height: 200px;
				margin-top: 40px;
			}
			
			@media only screen and (max-width: 800px){
				#buttons{
					display: inline-grid;
				}
				body{
					transform: 1.5;
				}
			}

		</style>

		<meta name = "viewport" content = "initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
		<link rel = "stylesheet" href = "https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
		<script src = "https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
		<script src = "https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
		<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
	</head>

	<body style = "background-color: transparent; overflow: none;">
		<div style = "height: 30px"></div>
		<div id = "quizMain" style = "display:none">
			<div style = "position: absolute; bottom: 10px; right: 30px; font-size: 20px"><p id = "demo" ></p></div>
			<div id = "quizCont" style = "margin-top: -10px;" class = "quiz-container container">
				<div id = "quiz"></div>
			</div>

			<div id = "buttons">
				<button class = "button" style = "margin-top: 223px; color: white; " id = "previous">Previous Question</button>
				<button class = "button" style = "margin-top: 223px; color: white; " id = "next">Next Question</button>
				<button class = "button" style = "margin-top: 223px; color: white; " id = "submit">Submit Practice</button>
				<div id = "results"></div>
			</div>
		
			<div id = "quiz-scoreboard" style = "display: none;">
				<img style = "width: 180px" src = "https://i.imgur.com/mHY0Xy8.png" alt = "brain" border = "0">
				<h4 id = "finalTxt" style = "font-size: 20px; margin-top: 5px; margin-bottom: 25px"></h4>
				<h3 style = "font-size: 20px; margin: 10px; " id = "resultime"></h3>
				<h3 style = "font-size: 20px; margin: 10px; " id = "resultcorrect"></h3>
				<h3 style = "font-size: 20px; margin: 10px; color: red; " id = "resultwrong"></h3>
				<h3 style = "font-size: 20px; margin: 10px; color: red; " id = "resultunansw"></h3>
				<h3 style = "font-size: 20px; margin-top: 10px; margin-bottom: 25px; " id = "resulttotal"></h3>
			</div>

			<button style = "display: none; color: white; " id = "backBtn" type = "button" class = "button">
				Back to Menu
			</button>
		
			<button style = "display: none; color: white; " id = "summaryBtn" type = "button" class = "button" data-toggle = "modal" data-target = "#exampleModalLong">
				Practice Summary
			</button>
		
			<button style = "display: none; color: white;" id = "tryBtn" type = "button" class = "button">
				Retry!
			</button>

			<div class = "modal fade" id = "exampleModalLong" tabindex = "-1" role = "dialog" aria-labelledby = "exampleModalLongTitle" aria-hidden = "true">
				<div class = "modal-dialog" style = "width:auto !important; margin:10px !important" role = "document">
					<div class = "modal-content">
						<div class = "modal-header">
							<button type = "button" class = "close" data-dismiss = "modal" aria-label = "Close">
								<span aria-hidden = "true">&times;</span>
							</button>
							<h5 class = "modal-title" id = "exampleModalLongTitle">Practice Summary</h5>
						</div>
						
						<div id = "summarybody" class = "modal-body">
							<table class = "table table-dark">
								<colgroup>
									<col span = "1" style = "width: 15%; ">
									<col span = "1" style = "width: 55%; ">
									<col span = "1" style = "width: 15%; ">
									<col span = "1" style = "width: 15%; ">
								</colgroup>
								
								<thead>
									<tr>
										<th scope = "col">#</th>
										<th scope = "col">Question</th>
										<th scope = "col">Correct Answer</th>
										<th scope = "col">User's Answer</th>
									</tr>
								</thead>

								<tbody id = "tbBody"></tbody>
							</table>
						</div>
					</div>
				</div>
			</div>
		</div>

		<div id = "start">
			<div style = "height: 125px"></div>
			<h3 id = "startquestions">Total Questions: 5, Total Time: 3m 0s</h3>
			<button style = "margin-top: 16px; color: white; " class = "button" onClick = 'start()'>Start Practice!</button>
		</div>
	</body>

	<script>
		var totalTime = 0;
		var time = 0
		function start() {

			var countDownDate = new Date("Jan 5, 2022 15:37:25").getTime();
			time = myQuestions.length * questionTime;
			totalTime = time;
			let mins = 0;
			let seconds = 0	

			var now = new Date().getTime();
				mins = Math.floor(((time % 3600) / 60));
				seconds = time % 60;

			// Find the distance between now and the count down date
			var distance = countDownDate - now;

			// Time calculations for days, hours, minutes and seconds
			// Output the result in an element with id="demo"
			document.getElementById("demo").innerHTML = mins + "m " + seconds + "s ";
			document.getElementById("quiz").style.display = "block";
			if (myQuestions.length > 0) {
				document.getElementById("results").innerHTML = quesNumber + " of " + myQuestions.length;
			}

			// If the count down is over, write some text
			if (distance < 0) {
				clearInterval(x);
				document.getElementById("demo").innerHTML = "EXPIRED";
			}
			
			if (mins === 0 && seconds === 0) {
				clearInterval(x);
				document.getElementById("demo").style.display = "none";
				showResults();
			}
			
			time = time - 1;

			x = setInterval(function() {
					
				// Get today's date and time
				var now = new Date().getTime();
				mins = Math.floor(((time % 3600) / 60));
				seconds = time % 60;

				// Find the distance between now and the count down date
				var distance = countDownDate - now;

				// Time calculations for days, hours, minutes and seconds
				// Output the result in an element with id="demo"
				document.getElementById("demo").innerHTML = mins + "m " + seconds + "s ";
				document.getElementById("quiz").style.display = "block";
				if (myQuestions.length > 0) {
					document.getElementById("results").innerHTML = quesNumber + " of " + myQuestions.length;
				}

				// If the count down is over, write some text 
				if (distance < 0) {
					clearInterval(x);
					document.getElementById("demo").innerHTML = "EXPIRED";
				}
				
				if (mins === 0 && seconds === 0) {
					clearInterval(x);
					document.getElementById("demo").style.display = "none";
					showResults();
				}
				
				time = time - 1;
			}, 1000);

			document.getElementById("start").style.display = "none";
			document.getElementById("quizMain").style.display = "block";
			
		}
		
		/* --------- Initialization of Quiz Variables */
		let quizScoreboard = document.getElementById("quiz-scoreboard");
		let resultTime = document.getElementById("resultime");
		let resultCorrectAnswers = document.getElementById("resultcorrect");
		let resultWrongAnswers = document.getElementById("resultwrong");
		let resultTotalQuestions = document.getElementById("resulttotal");
		let resultunanswered = document.getElementById("resultunansw");

		let quesNumber = 1;
		let check = false;
		let timeSec = + questionTime * numberOfQuestions;

		m = Math.floor(((timeSec % 3600) / 60));
		s = timeSec % 60;
		document.getElementById("startquestions").innerHTML = "Total Questions: " + numberOfQuestions + ", Total Time: " + m + "m:" + s + "s";

		// Functions
		function buildQuiz() {

			// variable to store the HTML output
			const output = [];
		
			// for each question...
			myQuestions.forEach(
				(currentQuestion, questionNumber) => {

					// variable to store the list of possible answers
					const answers = [];

					// and for each available answer...
					for (letter in currentQuestion.answers) {

						// ...add an HTML radio button
						answers.push(
							`<label>
								<input type = "radio" name = "question${questionNumber}" value = "${letter}">
								${letter} :
								${currentQuestion.answers[letter]}
							</label>`
						);
					}

					output.push(
						`<div class = "slide">
							<div class = "question"> ${currentQuestion.question} </div>
							<div class = "answers"> ${answers.join("")} </div>
						</div>`
					);					
				}
			);

			// finally combine our output list into one string of HTML and put it on the page
			quizContainer.innerHTML = output.join('');
		}

		function showResults() {
			// stop countdown if ended
			if(x){clearInterval(x)}
			check = true;
			let index = 1;
			document.getElementById("quizCont").style.display = "none";
			let tableBody = document.getElementById("tbBody");

			// gather answer containers from our quiz
			const answerContainers = quizContainer.querySelectorAll('.answers');

			// keep track of user's answers
			let numCorrect = 0;
			let count = 0;
			let wrongCount = 0;

			// for each question...
			myQuestions.forEach( (currentQuestion, questionNumber) => {

				// find selected answer
				const answerContainer = answerContainers[questionNumber];
				const selector = `input[name=question${questionNumber}]:checked`;
				const userAnswer = (answerContainer.querySelector(selector) || {}).value;

				let hh = currentQuestion.correctAnswer;
				let correctAns = "";
				let userAns = "";

				if (hh == "a") {
					correctAns = currentQuestion.answers.a;
				} else if (hh == "b") {
					correctAns = currentQuestion.answers.b;
				} else if (hh == "c") {
					correctAns = currentQuestion.answers.c;
				} else if (hh == "d") {
					correctAns = currentQuestion.answers.d;
				} else if (hh == "e") {
					correctAns = currentQuestion.answers.e;
				}

				if (userAnswer == "a") {
					userAns = currentQuestion.answers.a;
				} else if (userAnswer == "b") {
					userAns = currentQuestion.answers.b;
				} else if (userAnswer == "c") {
					userAns = currentQuestion.answers.c;
				} else if (userAnswer == "d") {
					userAns = currentQuestion.answers.d;
				} else if (userAnswer == "e") {
					userAns = currentQuestion.answers.e;
				}
				
				let tr = document.createElement('tr');
				if (correctAns === userAns) {
					tr.innerHTML = "<th scope='row'>" + index + "</th><td>" + currentQuestion.question + "</td> <td style = 'color: blue;'>" + correctAns + "</td><td style = 'color: blue;'>" + userAns + "</td>"
				}
				else {
					tr.innerHTML = "<th scope='row'>" + index + "</th><td>" + currentQuestion.question + "</td> <td style = 'color: red;'>" + correctAns + "</td><td style = 'color: red;'>" + userAns + "</td>"
				}
				
				tbBody.appendChild(tr);

				// if answer is correct
				if (userAnswer === currentQuestion.correctAnswer) {
					// add to the number of correct answers
					numCorrect++;
				}

				// if answer is blank
				else if (userAnswer === undefined) {
					count = count + 1;
				}

				// if answer is wrong
				else {
					wrongCount = wrongCount + 1;
				}
				
				index = index + 1;
				answerContainer.style.display = "none";
			});

			// show number of correct answers out of total
			resultsContainer.innerHTML = `${numCorrect} out of ${myQuestions.length}`;

			document.getElementById("demo").style.display = "none";
			document.getElementById("summaryBtn").style.display = "inline-block";
			document.getElementById("tryBtn").style.display = "inline-block";
			document.getElementById("backBtn").style.display = "inline-block";
			document.getElementById("buttons").style.display = "none";
			document.getElementById("quiz").style.display = "none";
			quizScoreboard.style.display = "block";
		
			let timee = totalTime - time;
			let mints = Math.floor(((timee % 3600) / 60)) ;
			let secs = timee % 60;
		
			resultTime.innerHTML = "Total Time: " + mints + "m " + secs + "s ";
			resultCorrectAnswers.innerHTML = "Correct Answers: "+ numCorrect;
			resultWrongAnswers.innerHTML = "Wrong Answers: "+ wrongCount;
			resultunanswered.innerHTML = "Unanswered: " + count;
			resultTotalQuestions.innerHTML = "Total Questions: " + myQuestions.length;

			let ques = + numberOfQuestions - wrongCount - count;
			let e = ques / numberOfQuestions;
			let percentage = e * 100;
			
			if (percentage == 100) {
				document.getElementById("finalTxt").innerHTML = "Excellent Work!!";
			} else if (percentage == 80) {
				document.getElementById("finalTxt").innerHTML = "So close! Try again!";
			} else if (percentage == 60) {
				document.getElementById("finalTxt").innerHTML = "You can do better. Try again.";
			} else if (percentage == 40) {
				document.getElementById("finalTxt").innerHTML = "You need to spend more time on this. Try again.";
			} else if (percentage == 20) {
				document.getElementById("finalTxt").innerHTML = "You need to spend a lot more time on this. Try again.";
			} else {
				document.getElementById("finalTxt").innerHTML = "I don't think you studied! Try again!";
			}
			MathJax.typesetPromise();
		}

		function showSlide(n) {

			slides[currentSlide].classList.remove('active-slide');
			slides[n].classList.add('active-slide');
			currentSlide = n;
			
			if (currentSlide === 0) {
				previousButton.style.display = 'none';
			}
			else {
				previousButton.style.display = 'inline-block';
			}

			if (currentSlide === slides.length-1) {
				nextButton.style.display = 'none';
				submitButton.style.display = 'inline-block';
			}
			else {
				nextButton.style.display = 'inline-block';
				submitButton.style.display = 'none';
			}
		}

		function showNextSlide() {
			showSlide(currentSlide + 1);
			quesNumber = quesNumber + 1;
			document.getElementById("results").innerHTML = quesNumber + " of " + myQuestions.length;
		}

		function showPreviousSlide() {
			showSlide(currentSlide - 1);
			quesNumber = quesNumber - 1;
			document.getElementById("results").innerHTML = quesNumber + " of " + myQuestions.length;
		}

		// model
		function ranModel() {

			// create questions following i
			for (let i = 0; i < numberOfQuestions; i++) {
				
				let q1 = Math.floor(Math.random() * 100);
				// 1) 25% 2 numbers
				// 2) 25% 3 numbers
				// 3) 12% 4 numbers
				// 4) 25% 2x
				// 5) 13% 3x
				let que, ans;
				let mcqMod = [];
				
				q1 = 95;
				if (q1 < 62) {
					// 1) 25% 2 numbers
					// 2) 25% 3 numbers
					// 3) 12% 4 numbers	

					// declare variables and answer
					let shcf = Math.floor(Math.random() * (30 - 1 + 1)) + 1;
					let cap;
					let multi = [];
					let r;
					
					if (shcf <= 20) {
						cap = 20;
					} else {
						cap = 10;
					}
					
					while (multi.length < 4) {
						r = Math.floor(Math.random() * (cap - 1 + 1)) + 1;
						if (multi.indexOf(r) === -1) {
							multi.push(r);
						}
					}

					multi.sort(function(a, b){return a - b});

					let a1, a2, a3, a4;

					a1 = shcf * multi[0];
					a2 = shcf * multi[1];
					a3 = shcf * multi[2];
					a4 = shcf * multi[3];

					switch (true) {
						case q1 < 25:
							que = a1 + ", " + a2;
							// loop from 1 to all numbers
							for (let i = 1; i <= a1 && i <= a2; i++) {

								// check if is factor of all numbers
								if (a1 % i == 0 && a2 % i == 0) {
									ans = i;
								}
							}
							break;
						case q1 < 50:
							que = a1 + ", " + a2 + ", " + a3;
							// loop from 1 to all numbers
							for (let i = 1; i <= a1 && i <= a2 && i <= a3; i++) {

								// check if is factor of all numbers
								if (a1 % i == 0 && a2 % i == 0 && a3 % i == 0) {
									ans = i;
								}
							}
							break;
						case q1 < 62:
							que = a1 + ", " + a2 + ", " + a3 + ", " + a4;
							// loop from 1 to all numbers
							for (let i = 1; i <= a1 && i <= a2 && i <= a3 && i <= a4; i++) {

								// check if is factor of all numbers
								if (a1 % i == 0 && a2 % i == 0 && a3 % i == 0 && a4 % i == 0) {
									ans = i;
								}
							}
							break;
					}
					
					// all mcq modifiers
					let mcqAllMod = [-31, -30, -29, -21, -20, -19, -11, -10, -9,
									-5, -4, -3, -2, -1, 1, 2, 3, 4, 5,
									9, 10, 11, 19, 20, 21, 29, 30, 31];

					// generate 4 random modifier positions
					let mcqRanModPos = [];
					while (mcqRanModPos.length < 4) {
						let r = Math.floor(Math.random() * 28);
						if (mcqRanModPos.indexOf(r) === -1
							&& ans + mcqAllMod[r] > 0) {
							mcqRanModPos.push(r);
						}
					}

					// generate 4 modifiers
					for (let j = 0; j < 4; j++) {
						mcqMod.push(mcqAllMod[mcqRanModPos[j]])
					}

					// generate 4 wrong choices
					mcqMod = mcqMod.map(value => value + ans)

				} else if (q1 < 75) {
					// 4) 13% 2x
					// A) 2^2 x 3^3, 2^3 x 3^2
					// i) 5% 2 same base
					// ii) 4% 1 same base
					// iii) 4% no same base

					// 4) 12% 3x
					// B) 2^2 x 3^3, 2^3 x 3^2, 2^4 x 3^1
					let queTemp1, queTemp2, queTemp3, queTemp4;
					let ansTemp;
					let baseMulti = 2;
					let baseChoice = 2; // at B change to 3
					let hcfBaseNum;
					let baseTotalNum;
					let baseArray = [];
					let powerArray = [];
					let wrongPowerArray = [];
					let hcfBase = [];
					let hcfPower = [];
					let hcfPowerTemp;
					let primeNum = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29];
					let primeChoicePos = [];
					let r, j, k, l;
					
					switch(true) {
						case q1 < 67:
							// generate 2 same base
							hcfBaseNum = 2;
							baseTotalNum = baseChoice * baseMulti - baseChoice * hcfBaseNum + hcfBaseNum;
							break;

						case q1 < 71:
							// generate 1 same base + 2 different base
							hcfBaseNum = 1;
							baseTotalNum = baseChoice * baseMulti - baseChoice * hcfBaseNum + hcfBaseNum;
							break;

						case q1 < 75:
							// generate 0 same base + 4 different base
							hcfBaseNum = 0;
							baseTotalNum = baseChoice * baseMulti - baseChoice * hcfBaseNum + hcfBaseNum;
							break;
					}

					// get all base prime choice position
					while (primeChoicePos.length < baseTotalNum) {
						r = Math.floor(Math.random() * 10);
						if (primeChoicePos.indexOf(r) === -1) {
							primeChoicePos.push(r);
						}
					}

					// get prime base number from prime choice position
					for (j = 0; j < baseTotalNum; j++) {
						baseArray.push(primeNum[primeChoicePos[j]]);
					}

					// get hcf base and power
					hcfBase = baseArray.slice(0, hcfBaseNum);

					// get power array
					while (powerArray.length < baseChoice) {
						let powerArrayTemp = [];
						
						// get power child array
						while (powerArrayTemp.length < baseMulti) {
							r = Math.floor(Math.random() * (9 - 1 + 1)) + 1;
							powerArrayTemp.push(r);
						}

						// check match any other child array
						k = 0;
						for (j = 0; j < powerArray.length; j++) {
							if (powerArrayTemp.every(function (element) {
									return powerArray[j].includes(element);
								}) == true) {
								k++;
							}
						}

						// will only add into powerArray if totally no match
						if (k == 0) {
							powerArray.push(powerArrayTemp);
						}
					}					
						
					// get minimum power
					for (j = 0; j < hcfBaseNum; j++){
						hcfPowerTemp = Math.min(powerArray[0][j], powerArray[1][j]);
						hcfPower.push(hcfPowerTemp);
					}

					// add in answer so that wrong answer won't duplicate with correct answer
					wrongPowerArray = [hcfPower];

					// generate 2 sets of wrong power
					while (wrongPowerArray.length < 3) {
						let powerArrayTemp = [];
						
						// get power child array
						while (powerArrayTemp.length < baseMulti) {
							r = Math.floor(Math.random() * (9 - 1 + 1)) + 1;
							powerArrayTemp.push(r);
						}

						// check match any other child array
						k = 0;
						for (j = 0; j < wrongPowerArray.length; j++) {
							if (powerArrayTemp.some(function (element) {
									return wrongPowerArray[j].includes(element);
								}) == true) {
								k++;
							}
						}

						// will only add into wrongPowerArray if totally no match
						if (k == 0) {
							wrongPowerArray.push(powerArrayTemp);
						}
					}

					// remove answer and left with all wrong power
					wrongPowerArray.splice(0, 1);

					// expo function for type as string;
					function expo(a, b) {
						if (b == 1) {
							return a;
						} else {
							return a + "^" + b;
						}
					}

					// generate question
					// baseChoice -> baseMulti -> basearray -> power array
					switch (true) {
						case q1 < 67:
							for (j = 0; j < baseChoice; j++) {
								// get index form
								queTemp1 = expo(baseArray[0], powerArray[j][0]);
								queTemp2 = expo(baseArray[1], powerArray[j][1]);

								// sort and then times together
								if (baseArray[0] < baseArray[1]) {
									queTemp3 = queTemp1 + "\\times" + queTemp2;
								} else {
									queTemp3 = queTemp2 + "\\times" + queTemp1;
								}

								// not first then need to have comma (,)
								if (j == 0) {
									que = queTemp3;
								} else {
									que = que + ", " + queTemp3;
								}
							}
							break;

						case q1 < 71:
							for (j = 0; j < baseChoice; j++) {
								queTemp1 = expo(baseArray[0], powerArray[j][0]);
								queTemp2 = expo(baseArray[j + 1], powerArray[j][1]);

								// sort and then times together
								if (baseArray[0] < baseArray[j + 1]) {
									queTemp3 = queTemp1 + "\\times" + queTemp2;
								} else {
									queTemp3 = queTemp2 + "\\times" + queTemp1;
								}

								// not first then need to have comma (,)
								if (j == 0) {
									que = queTemp3;
								} else {
									que = que + ", " + queTemp3;
								}
							}
							break;

						case q1 < 75:
							for (j = 0; j < baseChoice; j++) {
								queTemp1 = expo(baseArray[2 * j], powerArray[j][0]);
								queTemp2 = expo(baseArray[2 * j + 1], powerArray[j][1]);

								// sort and then times together
								if (baseArray[2 * j] < baseArray[2 * j + 1]) {
									queTemp3 = queTemp1 + "\\times" + queTemp2;
								} else {
									queTemp3 = queTemp2 + "\\times" + queTemp1;
								}

								// not first then need to have comma (,)
								if (j == 0) {
									que = queTemp3;
								} else {
									que = que + ", " + queTemp3;
								}
							}
							break;
					}
					
					// generate answer
					ans = 1;
					for (k = 0; k < hcfBaseNum; k++) {
						// get index form
						ansTemp = expo(hcfBase[k], hcfPower[k]);	
					
						// not first then need to have times (x)
						if (k == 0) {
							ans = ansTemp;
						} else {
							// sort
							if (baseArray[k] < baseArray[k - 1]) {
								ans = ansTemp + "\\times" + ans;
							} else {
								ans = ans + "\\times" + ansTemp;
							}
						}
					}

					// all wrong choices
					let mcqAllObj;
					switch (true) {
						case q1 < 67:
							mcqAllObj = [1,
										expo(hcfBase[0], hcfPower[0]),
										expo(hcfBase[1], hcfPower[1]),
										expo(hcfBase[0], wrongPowerArray[0][0]),
										expo(hcfBase[1], wrongPowerArray[0][1]),
										expo(hcfBase[0], wrongPowerArray[1][0]),
										expo(hcfBase[1], wrongPowerArray[1][1])];

							if (hcfBase[0] < hcfBase[1]) {
								mcqAllObj = mcqAllObj.concat([
											expo(hcfBase[0], hcfPower[0]) + "\\times" + expo(hcfBase[1], wrongPowerArray[0][1]),
											expo(hcfBase[0], hcfPower[0]) + "\\times" + expo(hcfBase[1], wrongPowerArray[1][1]),
											expo(hcfBase[0], wrongPowerArray[0][0]) + "\\times" + expo(hcfBase[1], hcfPower[1]),
											expo(hcfBase[0], wrongPowerArray[1][0]) + "\\times" + expo(hcfBase[1], hcfPower[1]),
											expo(hcfBase[0], wrongPowerArray[0][0]) + "\\times" + expo(hcfBase[1], wrongPowerArray[0][1]),
											expo(hcfBase[0], wrongPowerArray[1][0]) + "\\times" + expo(hcfBase[1], wrongPowerArray[1][1])
											]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(hcfBase[1], wrongPowerArray[0][1]) + "\\times" + expo(hcfBase[0], hcfPower[0]),
											expo(hcfBase[1], wrongPowerArray[1][1]) + "\\times" + expo(hcfBase[0], hcfPower[0]),
											expo(hcfBase[1], hcfPower[1]) + "\\times" + expo(hcfBase[0], wrongPowerArray[0][0]),
											expo(hcfBase[1], hcfPower[1]) + "\\times" + expo(hcfBase[0], wrongPowerArray[1][0]),
											expo(hcfBase[1], wrongPowerArray[0][1]) + "\\times" + expo(hcfBase[0], wrongPowerArray[0][0]),
											expo(hcfBase[1], wrongPowerArray[1][1]) + "\\times" + expo(hcfBase[0], wrongPowerArray[1][0])
											]);
							}
							break;

						case q1 < 71:
							mcqAllObj = [1,
										expo(baseArray[0], wrongPowerArray[0][0]),
										expo(baseArray[0], wrongPowerArray[1][0]),
										expo(baseArray[1], wrongPowerArray[0][0]),
										expo(baseArray[1], wrongPowerArray[1][0]),
										expo(baseArray[2], wrongPowerArray[0][1]),
										expo(baseArray[2], wrongPowerArray[1][1])];
							if (baseArray[0] < baseArray[1]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][0]),
											expo(baseArray[0], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][0]),
											expo(baseArray[0], wrongPowerArray[1][0]) + "\\times" + expo(baseArray[1], wrongPowerArray[1][0])
											]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[1], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[0], hcfPower[0]),
											expo(baseArray[1], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[0], wrongPowerArray[0][0]),
											expo(baseArray[1], wrongPowerArray[1][0]) + "\\times" + expo(baseArray[0], wrongPowerArray[1][0])
											]);
							}
							
							if (baseArray[0] < baseArray[2]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[2], wrongPowerArray[0][1]),
											expo(baseArray[0], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[2], wrongPowerArray[0][1]),
											expo(baseArray[0], wrongPowerArray[1][0]) + "\\times" + expo(baseArray[2], wrongPowerArray[1][1])
											]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[2], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[0], hcfPower[0]),
											expo(baseArray[2], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[0], wrongPowerArray[0][0]),
											expo(baseArray[2], wrongPowerArray[1][1]) + "\\times" + expo(baseArray[0], wrongPowerArray[1][0])
											]);
							}

							if (baseArray[1] < baseArray[2]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[1], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[2], wrongPowerArray[0][1]),
											expo(baseArray[1], wrongPowerArray[1][0]) + "\\times" + expo(baseArray[2], wrongPowerArray[1][1])
											]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[2], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][0]),
											expo(baseArray[2], wrongPowerArray[1][1]) + "\\times" + expo(baseArray[1], wrongPowerArray[1][0])
											]);
							}

							if (baseArray[0] < baseArray[1] && baseArray[1] < baseArray[2]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[2], wrongPowerArray[0][1]),
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[1], wrongPowerArray[1][0]) + "\\times" + expo(baseArray[2], wrongPowerArray[1][1])
											]);
							} else if (baseArray[0] < baseArray[2] && baseArray[2] < baseArray[1]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[2], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][0]),
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[2], wrongPowerArray[1][1]) + "\\times" + expo(baseArray[1], wrongPowerArray[1][0])
											]);
							} else if (baseArray[1] < baseArray[0] && baseArray[0] < baseArray[2]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[1], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[2], wrongPowerArray[0][1]),
											expo(baseArray[1], wrongPowerArray[1][0]) + "\\times" + expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[2], wrongPowerArray[1][1])
											]);
							} else if (baseArray[1] < baseArray[2] && baseArray[2] < baseArray[0]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[1], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[2], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[0], hcfPower[0]),
											expo(baseArray[1], wrongPowerArray[1][0]) + "\\times" + expo(baseArray[2], wrongPowerArray[1][1]) + "\\times" + expo(baseArray[0], hcfPower[0])
											]);
							} else if (baseArray[2] < baseArray[0] && baseArray[0] < baseArray[1]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[2], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][0]),
											expo(baseArray[2], wrongPowerArray[1][1]) + "\\times" + expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[1], wrongPowerArray[1][0])
											]);
							} else if (baseArray[2] < baseArray[1] && baseArray[1] < baseArray[0]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[2], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[0], hcfPower[0]),
											expo(baseArray[2], wrongPowerArray[1][1]) + "\\times" + expo(baseArray[1], wrongPowerArray[1][0]) + "\\times" + expo(baseArray[0], hcfPower[0])
											]);
							}
							break;

						case q1 < 75:
							mcqAllObj = [expo(baseArray[0], powerArray[0][0]),
										expo(baseArray[1], powerArray[0][1]),
										expo(baseArray[2], powerArray[1][0]),
										expo(baseArray[3], powerArray[1][1])];

							if (baseArray[0] < baseArray[1]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], powerArray[0][0]) + "\\times" + expo(baseArray[1], powerArray[0][1])]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[1], powerArray[0][1]) + "\\times" + expo(baseArray[0], powerArray[0][0])]);
							}

							if (baseArray[0] < baseArray[3]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], powerArray[0][0]) + "\\times" + expo(baseArray[3], powerArray[1][1])]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[3], powerArray[1][1]) + "\\times" + expo(baseArray[0], powerArray[0][0])]);
							}

							if (baseArray[2] < baseArray[1]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[2], powerArray[0][0]) + "\\times" + expo(baseArray[1], powerArray[0][1])]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[1], powerArray[0][1]) + "\\times" + expo(baseArray[2], powerArray[0][0])]);
							}

							if (baseArray[2] < baseArray[3]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[2], powerArray[0][0]) + "\\times" + expo(baseArray[3], powerArray[1][1])]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[3], powerArray[1][1]) + "\\times" + expo(baseArray[2], powerArray[0][0])]);
							}
							break;
					}

					// random 4 wrong answers
					let mcqAllObjPos = [];
					while (mcqAllObjPos.length < 4) {
						r = Math.floor(Math.random() * mcqAllObj.length);

						if (mcqAllObjPos.indexOf(r) === -1) {
							mcqAllObjPos.push(r);
						}
					}

					// map for mcq mod
					for (let j = 0; j < 4; j++) {
						mcqMod.push(mcqAllObj[mcqAllObjPos[j]]);
					}

				} else if (q1 < 87) {
					// 4) 12% 3x
					// B) 2^2 x 3^3, 2^3 x 3^2, 2^4 x 3^1
					// i) 4% 2 same base
					// ii) 4% 1 same base
					// iii) 4% no same base
					let queTemp1, queTemp2, queTemp3;
					let ansTemp;
					let baseMulti = 2;
					let baseChoice = 3;
					let hcfBaseNum;
					let baseTotalNum;
					let baseArray = [];
					let powerArray = [];
					let wrongPowerArray = [];
					let hcfBase = [];
					let hcfPower = [];
					let hcfPowerTemp;
					let primeNum = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29];
					let primeChoicePos = [];
					let r, j, k, l;

					switch(true) {
						case q1 < 79:
							// generate 2 same base
							hcfBaseNum = 2;
							baseTotalNum = baseChoice * baseMulti - baseChoice * hcfBaseNum + hcfBaseNum;
							break;

						case q1 < 83:
							// generate 1 same base + 2 different base
							hcfBaseNum = 1;
							baseTotalNum = baseChoice * baseMulti - baseChoice * hcfBaseNum + hcfBaseNum;
							break;

						case q1 < 87:
							// generate 0 same base + 4 different base
							hcfBaseNum = 0;
							baseTotalNum = baseChoice * baseMulti - baseChoice * hcfBaseNum + hcfBaseNum;
							break;
					}

					// get all base prime choice position
					while (primeChoicePos.length < baseTotalNum) {
						r = Math.floor(Math.random() * 10);
						if (primeChoicePos.indexOf(r) === -1) {
							primeChoicePos.push(r);
						}
					}

					// get prime base number from prime choice position
					for (j = 0; j < baseTotalNum; j++) {
						baseArray.push(primeNum[primeChoicePos[j]]);
					}

					// get hcf base and power
					hcfBase = baseArray.slice(0, hcfBaseNum);

					// get power array
					while (powerArray.length < baseChoice) {
						let powerArrayTemp = [];
						
						// get power child array
						while (powerArrayTemp.length < baseMulti) {
							r = Math.floor(Math.random() * (9 - 1 + 1)) + 1;
							powerArrayTemp.push(r);
						}

						// check match any other child array
						k = 0;
						for (j = 0; j < powerArray.length; j++) {
							if (powerArrayTemp.every(function (element) {
									return powerArray[j].includes(element);
								}) == true) {
								k++;
							}
						}

						// will only add into powerArray if totally no match
						if (k == 0) {
							powerArray.push(powerArrayTemp);
						}
					}					
						
					// get minimum power
					for (j = 0; j < hcfBaseNum; j++){
						hcfPowerTemp = Math.min(powerArray[0][j], powerArray[1][j], powerArray[2][j]);
						hcfPower.push(hcfPowerTemp);
					}

					// add in answer so that wrong answer won't duplicate with correct answer
					wrongPowerArray = [hcfPower];

					// generate 2 sets of wrong power
					while (wrongPowerArray.length < 3) {
						let powerArrayTemp = [];
						
						// get power child array
						while (powerArrayTemp.length < baseMulti) {
							r = Math.floor(Math.random() * (9 - 1 + 1)) + 1;
							powerArrayTemp.push(r);
						}

						// check match any other child array
						k = 0;
						for (j = 0; j < wrongPowerArray.length; j++) {
							if (powerArrayTemp.some(function (element) {
									return wrongPowerArray[j].includes(element);
								}) == true) {
								k++;
							}
						}

						// will only add into wrongPowerArray if totally no match
						if (k == 0) {
							wrongPowerArray.push(powerArrayTemp);
						}
					}

					// remove answer and left with all wrong power
					wrongPowerArray.splice(0, 1);

					// expo function for type as string;
					function expo(a, b) {
						if (b == 1) {
							return a;
						} else {
							return a + "^" + b;
						}
					}

					// generate question
					// baseChoice -> baseMulti -> basearray -> power array
					switch (true) {
						case q1 < 79:
							for (j = 0; j < baseChoice; j++) {
								// get index form
								queTemp1 = expo(baseArray[0], powerArray[j][0]);
								queTemp2 = expo(baseArray[1], powerArray[j][1]);

								// sort and then times together
								if (baseArray[0] < baseArray[1]) {
									queTemp3 = queTemp1 + "\\times" + queTemp2;
								} else {
									queTemp3 = queTemp2 + "\\times" + queTemp1;
								}

								// not first then need to have comma (,)
								if (j == 0) {
									que = queTemp3;
								} else {
									que = que + ", " + queTemp3;
								}
							}
							break;

						case q1 < 83:
							for (j = 0; j < baseChoice; j++) {
								queTemp1 = expo(baseArray[0], powerArray[j][0]);
								queTemp2 = expo(baseArray[j + 1], powerArray[j][1]);

								// sort and then times together
								if (baseArray[0] < baseArray[j + 1]) {
									queTemp3 = queTemp1 + "\\times" + queTemp2;
								} else {
									queTemp3 = queTemp2 + "\\times" + queTemp1;
								}

								// not first then need to have comma (,)
								if (j == 0) {
									que = queTemp3;
								} else {
									que = que + ", " + queTemp3;
								}
							}
							break;

						case q1 < 87:
							for (j = 0; j < baseChoice; j++) {
								queTemp1 = expo(baseArray[2 * j], powerArray[j][0]);
								queTemp2 = expo(baseArray[2 * j + 1], powerArray[j][1]);

								// sort and then times together
								if (baseArray[2 * j] < baseArray[2 * j + 1]) {
									queTemp3 = queTemp1 + "\\times" + queTemp2;
								} else {
									queTemp3 = queTemp2 + "\\times" + queTemp1;
								}

								// not first then need to have comma (,)
								if (j == 0) {
									que = queTemp3;
								} else {
									que = que + ", " + queTemp3;
								}
							}
							break;
					}
					
					// generate answer
					ans = 1;
					for (k = 0; k < hcfBaseNum; k++) {
						// get index form
						ansTemp = expo(hcfBase[k], hcfPower[k]);	
					
						// not first then need to have times (x)
						if (k == 0) {
							ans = ansTemp;
						} else {
							// sort
							if (baseArray[k] < baseArray[k - 1]) {
								ans = ansTemp + "\\times" + ans;
							} else {
								ans = ans + "\\times" + ansTemp;
							}
						}
					}

					// all wrong choices
					let mcqAllObj;
					switch (true) {
						case q1 < 79:
							mcqAllObj = [1,
										expo(hcfBase[0], hcfPower[0]),
										expo(hcfBase[1], hcfPower[1]),
										expo(hcfBase[0], wrongPowerArray[0][0]),
										expo(hcfBase[1], wrongPowerArray[0][1]),
										expo(hcfBase[0], wrongPowerArray[1][0]),
										expo(hcfBase[1], wrongPowerArray[1][1])];

							if (hcfBase[0] < hcfBase[1]) {
								mcqAllObj = mcqAllObj.concat([
											expo(hcfBase[0], hcfPower[0]) + "\\times" + expo(hcfBase[1], wrongPowerArray[0][1]),
											expo(hcfBase[0], hcfPower[0]) + "\\times" + expo(hcfBase[1], wrongPowerArray[1][1]),
											expo(hcfBase[0], wrongPowerArray[0][0]) + "\\times" + expo(hcfBase[1], hcfPower[1]),
											expo(hcfBase[0], wrongPowerArray[1][0]) + "\\times" + expo(hcfBase[1], hcfPower[1]),
											expo(hcfBase[0], wrongPowerArray[0][0]) + "\\times" + expo(hcfBase[1], wrongPowerArray[0][1]),
											expo(hcfBase[0], wrongPowerArray[1][0]) + "\\times" + expo(hcfBase[1], wrongPowerArray[1][1])
											]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(hcfBase[1], wrongPowerArray[0][1]) + "\\times" + expo(hcfBase[0], hcfPower[0]),
											expo(hcfBase[1], wrongPowerArray[1][1]) + "\\times" + expo(hcfBase[0], hcfPower[0]),
											expo(hcfBase[1], hcfPower[1]) + "\\times" + expo(hcfBase[0], wrongPowerArray[0][0]),
											expo(hcfBase[1], hcfPower[1]) + "\\times" + expo(hcfBase[0], wrongPowerArray[1][0]),
											expo(hcfBase[1], wrongPowerArray[0][1]) + "\\times" + expo(hcfBase[0], wrongPowerArray[0][0]),
											expo(hcfBase[1], wrongPowerArray[1][1]) + "\\times" + expo(hcfBase[0], wrongPowerArray[1][0])
											]);
							}
							break;

						case q1 < 83:
							mcqAllObj = [1,
										expo(baseArray[0], wrongPowerArray[0][0]),
										expo(baseArray[0], wrongPowerArray[1][0]),
										expo(baseArray[1], wrongPowerArray[0][0]),
										expo(baseArray[1], wrongPowerArray[1][0]),
										expo(baseArray[2], wrongPowerArray[0][1]),
										expo(baseArray[2], wrongPowerArray[1][1]),
										expo(baseArray[3], wrongPowerArray[0][1]),
										expo(baseArray[3], wrongPowerArray[1][1])];
							if (baseArray[0] < baseArray[1]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][0]),
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[1], wrongPowerArray[1][0]),
											expo(baseArray[0], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][0]),
											expo(baseArray[0], wrongPowerArray[1][0]) + "\\times" + expo(baseArray[1], wrongPowerArray[1][0])
											]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[1], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[0], hcfPower[0]),
											expo(baseArray[1], wrongPowerArray[1][0]) + "\\times" + expo(baseArray[0], hcfPower[0]),
											expo(baseArray[1], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[0], wrongPowerArray[0][0]),
											expo(baseArray[1], wrongPowerArray[1][0]) + "\\times" + expo(baseArray[0], wrongPowerArray[1][0])
											]);
							}
							
							if (baseArray[0] < baseArray[2]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[2], wrongPowerArray[0][1]),
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[2], wrongPowerArray[1][1]),
											expo(baseArray[0], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[2], wrongPowerArray[0][1]),
											expo(baseArray[0], wrongPowerArray[1][0]) + "\\times" + expo(baseArray[2], wrongPowerArray[1][1])
											]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[2], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[0], hcfPower[0]),
											expo(baseArray[2], wrongPowerArray[1][1]) + "\\times" + expo(baseArray[0], hcfPower[0]),
											expo(baseArray[2], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[0], wrongPowerArray[0][0]),
											expo(baseArray[2], wrongPowerArray[1][1]) + "\\times" + expo(baseArray[0], wrongPowerArray[1][0])
											]);
							}

							if (baseArray[0] < baseArray[3]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[3], wrongPowerArray[0][1]),
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[3], wrongPowerArray[1][1]),
											expo(baseArray[0], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[3], wrongPowerArray[0][1]),
											expo(baseArray[0], wrongPowerArray[1][0]) + "\\times" + expo(baseArray[3], wrongPowerArray[1][1])
											]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[3], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[0], hcfPower[0]),
											expo(baseArray[3], wrongPowerArray[1][1]) + "\\times" + expo(baseArray[0], hcfPower[0]),
											expo(baseArray[3], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[0], wrongPowerArray[0][0]),
											expo(baseArray[3], wrongPowerArray[1][1]) + "\\times" + expo(baseArray[0], wrongPowerArray[1][0])
											]);
							}

							if (baseArray[1] < baseArray[2]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[1], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[2], wrongPowerArray[0][1]),
											expo(baseArray[1], wrongPowerArray[1][0]) + "\\times" + expo(baseArray[2], wrongPowerArray[1][1])
											]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[2], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][0]),
											expo(baseArray[2], wrongPowerArray[1][1]) + "\\times" + expo(baseArray[1], wrongPowerArray[1][0])
											]);
							}

							if (baseArray[1] < baseArray[3]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[1], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[3], wrongPowerArray[0][1]),
											expo(baseArray[1], wrongPowerArray[1][0]) + "\\times" + expo(baseArray[3], wrongPowerArray[1][1])
											]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[3], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][0]),
											expo(baseArray[3], wrongPowerArray[1][1]) + "\\times" + expo(baseArray[1], wrongPowerArray[1][0])
											]);
							}

							if (baseArray[0] < baseArray[1] && baseArray[1] < baseArray[2]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[2], wrongPowerArray[0][1]),
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[1], wrongPowerArray[1][0]) + "\\times" + expo(baseArray[2], wrongPowerArray[1][1])
											]);
							} else if (baseArray[0] < baseArray[2] && baseArray[2] < baseArray[1]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[2], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][0]),
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[2], wrongPowerArray[1][1]) + "\\times" + expo(baseArray[1], wrongPowerArray[1][0])
											]);
							} else if (baseArray[1] < baseArray[0] && baseArray[0] < baseArray[2]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[1], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[2], wrongPowerArray[0][1]),
											expo(baseArray[1], wrongPowerArray[1][0]) + "\\times" + expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[2], wrongPowerArray[1][1])
											]);
							} else if (baseArray[1] < baseArray[2] && baseArray[2] < baseArray[0]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[1], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[2], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[0], hcfPower[0]),
											expo(baseArray[1], wrongPowerArray[1][0]) + "\\times" + expo(baseArray[2], wrongPowerArray[1][1]) + "\\times" + expo(baseArray[0], hcfPower[0])
											]);
							} else if (baseArray[2] < baseArray[0] && baseArray[0] < baseArray[1]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[2], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][0]),
											expo(baseArray[2], wrongPowerArray[1][1]) + "\\times" + expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[1], wrongPowerArray[1][0])
											]);
							} else if (baseArray[2] < baseArray[1] && baseArray[1]< baseArray[0]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[2], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[0], hcfPower[0]),
											expo(baseArray[2], wrongPowerArray[1][1]) + "\\times" + expo(baseArray[1], wrongPowerArray[1][0]) + "\\times" + expo(baseArray[0], hcfPower[0])
											]);
							}
							break;

						case q1 < 87:
							mcqAllObj = [expo(baseArray[0], powerArray[0][0]),
										expo(baseArray[1], powerArray[0][1]),
										expo(baseArray[2], powerArray[1][0]),
										expo(baseArray[3], powerArray[1][1]),
										expo(baseArray[4], powerArray[1][0]),
										expo(baseArray[5], powerArray[1][1])];

							if (baseArray[0] < baseArray[1]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], powerArray[0][0]) + "\\times" + expo(baseArray[1], powerArray[0][1])]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[1], powerArray[0][1]) + "\\times" + expo(baseArray[0], powerArray[0][0])]);
							}

							if (baseArray[0] < baseArray[3]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], powerArray[0][0]) + "\\times" + expo(baseArray[3], powerArray[1][1])]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[3], powerArray[1][1]) + "\\times" + expo(baseArray[0], powerArray[0][0])]);
							}

							
							if (baseArray[0] < baseArray[5]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], powerArray[0][0]) + "\\times" + expo(baseArray[5], powerArray[1][1])]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[5], powerArray[1][1]) + "\\times" + expo(baseArray[0], powerArray[0][0])]);
							}

							if (baseArray[2] < baseArray[1]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[2], powerArray[0][0]) + "\\times" + expo(baseArray[1], powerArray[0][1])]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[1], powerArray[0][1]) + "\\times" + expo(baseArray[2], powerArray[0][0])]);
							}

							if (baseArray[2] < baseArray[3]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[2], powerArray[0][0]) + "\\times" + expo(baseArray[3], powerArray[1][1])]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[3], powerArray[1][1]) + "\\times" + expo(baseArray[2], powerArray[0][0])]);
							}

							if (baseArray[2] < baseArray[5]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[2], powerArray[0][0]) + "\\times" + expo(baseArray[5], powerArray[1][1])]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[5], powerArray[1][1]) + "\\times" + expo(baseArray[2], powerArray[0][0])]);
							}
							break;
					}

					// random 4 wrong answers
					let mcqAllObjPos = [];
					while (mcqAllObjPos.length < 4) {
						r = Math.floor(Math.random() * mcqAllObj.length);

						if (mcqAllObjPos.indexOf(r) === -1) {
							mcqAllObjPos.push(r);
						}
					}

					// map for mcq mod
					for (let j = 0; j < 4; j++) {
						mcqMod.push(mcqAllObj[mcqAllObjPos[j]]);
					}
				} else if (q1 < 94) {
					// 5) 7% 2x
					// A) 2^2 x 3^3 x 5^5, 2^3 x 3^2 x 5^4
					// i) 3% 3 same base
					// ii) 2% 2 same base
					// iii) 2% 1 same base
					let queTemp1, queTemp2, queTemp3;
					let ansTemp;
					let baseMulti = 3;
					let baseChoice = 2;
					let hcfBaseNum;
					let baseTotalNum;
					let baseArray = [];
					let powerArray = [];
					let wrongPowerArray = [];
					let hcfBase = [];
					let hcfPower = [];
					let hcfPowerTemp;
					let primeNum = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29];
					let primeChoicePos = [];
					let r, j, k, l;

					switch(true) {
						case q1 < 90:
							// generate 3 same base
							hcfBaseNum = 3;
							baseTotalNum = baseChoice * baseMulti - baseChoice * hcfBaseNum + hcfBaseNum;
							break;

						case q1 < 92:
							// generate 2 same base + 2 different base
							hcfBaseNum = 2;
							baseTotalNum = baseChoice * baseMulti - baseChoice * hcfBaseNum + hcfBaseNum;
							break;

						case q1 < 94:
							// generate 1 same base + 4 different base
							hcfBaseNum = 1;
							baseTotalNum = baseChoice * baseMulti - baseChoice * hcfBaseNum + hcfBaseNum;
							break;
					}

					// get all base prime choice position
					while (primeChoicePos.length < baseTotalNum) {
						r = Math.floor(Math.random() * 10);
						if (primeChoicePos.indexOf(r) === -1) {
							primeChoicePos.push(r);
						}
					}

					// get prime base number from prime choice position
					for (j = 0; j < baseTotalNum; j++) {
						baseArray.push(primeNum[primeChoicePos[j]]);
					}

					// get hcf base and power
					hcfBase = baseArray.slice(0, hcfBaseNum);

					// get power array
					while (powerArray.length < baseChoice) {
						let powerArrayTemp = [];
						
						// get power child array
						while (powerArrayTemp.length < baseMulti) {
							r = Math.floor(Math.random() * (9 - 1 + 1)) + 1;
							powerArrayTemp.push(r);
						}

						// check match any other child array
						k = 0;
						for (j = 0; j < powerArray.length; j++) {
							if (powerArrayTemp.every(function (element) {
									return powerArray[j].includes(element);
								}) == true) {
								k++;
							}
						}

						// will only add into powerArray if totally no match
						if (k == 0) {
							powerArray.push(powerArrayTemp);
						}
					}				
						
					// get minimum power
					for (j = 0; j < hcfBaseNum; j++){
						hcfPowerTemp = Math.min(powerArray[0][j], powerArray[1][j]);
						hcfPower.push(hcfPowerTemp);
					}

					// add in answer so that wrong answer won't duplicate with correct answer
					wrongPowerArray = [hcfPower];

					// generate 2 sets of wrong power
					while (wrongPowerArray.length < 3) {
						let powerArrayTemp = [];
						
						// get power child array
						while (powerArrayTemp.length < baseMulti) {
							r = Math.floor(Math.random() * (9 - 1 + 1)) + 1;
							powerArrayTemp.push(r);
						}

						// check match any other child array
						k = 0;
						for (j = 0; j < wrongPowerArray.length; j++) {
							if (powerArrayTemp.some(function (element) {
									return wrongPowerArray[j].includes(element);
								}) == true) {
								k++;
							}
						}

						// will only add into wrongPowerArray if totally no match
						if (k == 0) {
							wrongPowerArray.push(powerArrayTemp);
						}
					}

					// remove answer and left with all wrong power
					wrongPowerArray.splice(0, 1);

					// expo function for type as string;
					function expo(a, b) {
						if (b == 1) {
							return a;
						} else {
							return a + "^" + b;
						}
					}

					// generate question
					// baseChoice -> baseMulti -> basearray -> power array
					switch (true) {
						case q1 < 90:
							for (j = 0; j < baseChoice; j++) {
								for (k = 0; k < baseMulti; k++) {
									// get index form
									queTemp1 = expo(baseArray[k], powerArray[j][k]);

									if (k == 0) {
										queTemp2 = queTemp1;
									} else if (k == 1) {
										//sort
										if (baseArray[k] < baseArray[k - 1]) {
											queTemp2 = queTemp1 + "\\times" + queTemp2;
										} else {
											queTemp2 = queTemp2 + "\\times" + queTemp1;
										}
									} else if (k == 2) {
										// sort
										if (baseArray[k] < baseArray[k - 1] && baseArray[k] < baseArray[k - 2]) {
											queTemp2 = queTemp1 + "\\times" + queTemp2;
										} else if (baseArray[k] > baseArray[k - 1] && baseArray[k] > baseArray[k - 2]) {
											queTemp2 = queTemp2 + "\\times" + queTemp1;
										} else {
											queTemp2 = queTemp2.slice(0, queTemp2.indexOf("\\")).
													concat("\\times").concat(queTemp1).
													concat("\\times").concat(queTemp2.slice(queTemp2.indexOf("\\") + 6));
										}
									}
								}

								// not first then need to have comma (,)
								if (j == 0) {
									que = queTemp2;
								} else {
									que = que + ", " + queTemp2;
								}
							}
							break;

						case q1 < 92:
							for (j = 0; j < baseChoice; j++) {
								for (k = 0; k < baseMulti; k++) {
									// get index form
									// special treatment for 4th number
									if (k == 2 && j == 1) {
										l = 3;
									} else {
										l = k;
									}

									queTemp1 = expo(baseArray[l], powerArray[j][k]);

									if (k == 0) {
										queTemp2 = queTemp1;
									} else if (k == 1) {
										//sort
										if (baseArray[k] < baseArray[k - 1]) {
											queTemp2 = queTemp1 + "\\times" + queTemp2;
										} else {
											queTemp2 = queTemp2 + "\\times" + queTemp1;
										}
									} else if (k == 2) {
										// sort
										if (baseArray[l] < baseArray[k - 1] && baseArray[l] < baseArray[k - 2]) {
											queTemp2 = queTemp1 + "\\times" + queTemp2;
										} else if (baseArray[l] > baseArray[k - 1] && baseArray[l] > baseArray[k - 2]) {
											queTemp2 = queTemp2 + "\\times" + queTemp1;
										} else {
											queTemp2 = queTemp2.slice(0, queTemp2.indexOf("\\")).
													concat("\\times").concat(queTemp1).
													concat("\\times").concat(queTemp2.slice(queTemp2.indexOf("\\") + 6));
										}
									}
								}

								// not first then need to have comma (,)
								if (j == 0) {
									que = queTemp2;
								} else {
									que = que + ", " + queTemp2;
								}
							}
							break;

						case q1 < 94:
							for (j = 0; j < baseChoice; j++) {
								for (k = 0; k < baseMulti; k++) {
									// get index form
									if (k == 0) {
										l = 0;
									} else {
										l = 2 * j + k;
									}
									queTemp1 = expo(baseArray[l], powerArray[j][k]);

									if (k == 0) {
										queTemp2 = queTemp1;
									} else if (k == 1) {
										//sort
										if (baseArray[2 * j + k] < baseArray[k - 1]) {
											queTemp2 = queTemp1 + "\\times" + queTemp2;
										} else {
											queTemp2 = queTemp2 + "\\times" + queTemp1;
										}
									} else if (k == 2) {
										// sort
										if (baseArray[l] < baseArray[2 * j + k - 1] && baseArray[l] < baseArray[k - 2]) {
											queTemp2 = queTemp1 + "\\times" + queTemp2;
										} else if (baseArray[l] > baseArray[2 * j + k - 1] && baseArray[l] > baseArray[k - 2]) {
											queTemp2 = queTemp2 + "\\times" + queTemp1;
										} else {
											queTemp2 = queTemp2.slice(0, queTemp2.indexOf("\\")).
													concat("\\times").concat(queTemp1).
													concat("\\times").concat(queTemp2.slice(queTemp2.indexOf("\\") + 6));
										}
									}
								}

								// not first then need to have comma (,)
								if (j == 0) {
									que = queTemp2;
								} else {
									que = que + ", " + queTemp2;
								}
							}
							break;
					}
					
					// generate answer
					ans = 1;
					for (k = 0; k < hcfBaseNum; k++) {
						// get index form
						ansTemp = expo(hcfBase[k], hcfPower[k]);	
					
						// not first then need to have times (x)
						if (k == 0) {
							ans = ansTemp;
						} else if (k == 1) {
							// sort
							if (baseArray[k] < baseArray[k - 1]) {
								ans = ansTemp + "\\times" + ans;
							} else {
								ans = ans + "\\times" + ansTemp;
							}
						} else if (k == 2) {
							// sort
							if (baseArray[k] < baseArray[k - 1] && baseArray[k] < baseArray[k - 2]) {
								ans = ansTemp + "\\times" + ans;
							} else if (baseArray[k] > baseArray[k - 1] && baseArray[k] > baseArray[k - 2]) {
								ans = ans + "\\times" + ansTemp;
							} else {
								ans = ans.slice(0, ans.indexOf("\\")).
										concat("\\times").concat(ansTemp).
										concat("\\times").concat(ans.slice(ans.indexOf("\\") + 6));
							}
						}
					}

					// all wrong choices
					let mcqAllObj;
					switch (true) {
						case q1 < 90:
							mcqAllObj = [1,
										expo(hcfBase[0], hcfPower[0]),
										expo(hcfBase[1], hcfPower[1]),
										expo(hcfBase[2], hcfPower[2]),
										expo(hcfBase[0], wrongPowerArray[0][0]),
										expo(hcfBase[1], wrongPowerArray[0][1]),
										expo(hcfBase[2], wrongPowerArray[0][2]),
										expo(hcfBase[0], wrongPowerArray[1][0]),
										expo(hcfBase[1], wrongPowerArray[1][1]),
										expo(hcfBase[2], wrongPowerArray[1][2])];

							if (hcfBase[0] < hcfBase[1]) {
								mcqAllObj = mcqAllObj.concat([
											expo(hcfBase[0], hcfPower[0]) + "\\times" + expo(hcfBase[1], wrongPowerArray[0][1]),
											expo(hcfBase[0], hcfPower[0]) + "\\times" + expo(hcfBase[1], wrongPowerArray[1][1]),
											expo(hcfBase[0], wrongPowerArray[0][0]) + "\\times" + expo(hcfBase[1], hcfPower[1]),
											expo(hcfBase[0], wrongPowerArray[1][0]) + "\\times" + expo(hcfBase[1], hcfPower[1]),
											expo(hcfBase[0], wrongPowerArray[0][0]) + "\\times" + expo(hcfBase[1], wrongPowerArray[0][1]),
											expo(hcfBase[0], wrongPowerArray[1][0]) + "\\times" + expo(hcfBase[1], wrongPowerArray[1][1])
											]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(hcfBase[1], wrongPowerArray[0][1]) + "\\times" + expo(hcfBase[0], hcfPower[0]),
											expo(hcfBase[1], wrongPowerArray[1][1]) + "\\times" + expo(hcfBase[0], hcfPower[0]),
											expo(hcfBase[1], hcfPower[1]) + "\\times" + expo(hcfBase[0], wrongPowerArray[0][0]),
											expo(hcfBase[1], hcfPower[1]) + "\\times" + expo(hcfBase[0], wrongPowerArray[1][0]),
											expo(hcfBase[1], wrongPowerArray[0][1]) + "\\times" + expo(hcfBase[0], wrongPowerArray[0][0]),
											expo(hcfBase[1], wrongPowerArray[1][1]) + "\\times" + expo(hcfBase[0], wrongPowerArray[1][0])
											]);
							}

							if (hcfBase[0] < hcfBase[2]) {
								mcqAllObj = mcqAllObj.concat([
											expo(hcfBase[0], hcfPower[0]) + "\\times" + expo(hcfBase[2], wrongPowerArray[0][2]),
											expo(hcfBase[0], hcfPower[0]) + "\\times" + expo(hcfBase[2], wrongPowerArray[1][2]),
											expo(hcfBase[0], wrongPowerArray[0][0]) + "\\times" + expo(hcfBase[2], hcfPower[2]),
											expo(hcfBase[0], wrongPowerArray[1][0]) + "\\times" + expo(hcfBase[2], hcfPower[2]),
											expo(hcfBase[0], wrongPowerArray[0][0]) + "\\times" + expo(hcfBase[2], wrongPowerArray[0][2]),
											expo(hcfBase[0], wrongPowerArray[1][0]) + "\\times" + expo(hcfBase[2], wrongPowerArray[1][2])
											]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(hcfBase[2], wrongPowerArray[0][2]) + "\\times" + expo(hcfBase[0], hcfPower[0]),
											expo(hcfBase[2], wrongPowerArray[1][2]) + "\\times" + expo(hcfBase[0], hcfPower[0]),
											expo(hcfBase[2], hcfPower[2]) + "\\times" + expo(hcfBase[0], wrongPowerArray[0][0]),
											expo(hcfBase[2], hcfPower[2]) + "\\times" + expo(hcfBase[0], wrongPowerArray[1][0]),
											expo(hcfBase[2], wrongPowerArray[0][2]) + "\\times" + expo(hcfBase[0], wrongPowerArray[0][0]),
											expo(hcfBase[2], wrongPowerArray[1][2]) + "\\times" + expo(hcfBase[0], wrongPowerArray[1][0])
											]);
							}

							if (hcfBase[1] < hcfBase[2]) {
								mcqAllObj = mcqAllObj.concat([
											expo(hcfBase[1], hcfPower[1]) + "\\times" + expo(hcfBase[2], wrongPowerArray[0][2]),
											expo(hcfBase[1], hcfPower[1]) + "\\times" + expo(hcfBase[2], wrongPowerArray[1][2]),
											expo(hcfBase[1], wrongPowerArray[0][1]) + "\\times" + expo(hcfBase[2], hcfPower[2]),
											expo(hcfBase[1], wrongPowerArray[1][1]) + "\\times" + expo(hcfBase[2], hcfPower[2]),
											expo(hcfBase[1], wrongPowerArray[0][1]) + "\\times" + expo(hcfBase[2], wrongPowerArray[0][2]),
											expo(hcfBase[1], wrongPowerArray[1][1]) + "\\times" + expo(hcfBase[2], wrongPowerArray[1][2])
											]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(hcfBase[2], wrongPowerArray[0][2]) + "\\times" + expo(hcfBase[1], hcfPower[1]),
											expo(hcfBase[2], wrongPowerArray[1][2]) + "\\times" + expo(hcfBase[1], hcfPower[1]),
											expo(hcfBase[2], hcfPower[2]) + "\\times" + expo(hcfBase[1], wrongPowerArray[0][1]),
											expo(hcfBase[2], hcfPower[2]) + "\\times" + expo(hcfBase[1], wrongPowerArray[1][1]),
											expo(hcfBase[2], wrongPowerArray[0][2]) + "\\times" + expo(hcfBase[1], wrongPowerArray[0][1]),
											expo(hcfBase[2], wrongPowerArray[1][2]) + "\\times" + expo(hcfBase[1], wrongPowerArray[1][1])
											]);
							}

							if (hcfBase[0] < hcfBase[1] && hcfBase[1] < hcfBase[2]) {
								mcqAllObj = mcqAllObj.concat([
											expo(hcfBase[0], hcfPower[0]) + "\\times" + expo(hcfBase[1], wrongPowerArray[0][1]) + "\\times" + expo(hcfBase[2], wrongPowerArray[0][2]),
											expo(hcfBase[0], hcfPower[0]) + "\\times" + expo(hcfBase[1], wrongPowerArray[1][1]) + "\\times" + expo(hcfBase[2], wrongPowerArray[1][2]),
											expo(hcfBase[0], wrongPowerArray[0][0]) + "\\times" + expo(hcfBase[1], hcfPower[1]) + "\\times" + expo(hcfBase[2], wrongPowerArray[0][2]),
											expo(hcfBase[0], wrongPowerArray[1][0]) + "\\times" + expo(hcfBase[1], hcfPower[1]) + "\\times" + expo(hcfBase[2], wrongPowerArray[1][2]),
											expo(hcfBase[0], wrongPowerArray[0][0]) + "\\times" + expo(hcfBase[1], wrongPowerArray[0][1]) + "\\times" + expo(hcfBase[2], hcfPower[2]),
											expo(hcfBase[0], wrongPowerArray[1][0]) + "\\times" + expo(hcfBase[1], wrongPowerArray[1][1]) + "\\times" + expo(hcfBase[2], hcfPower[2])
											]);
							} else if (hcfBase[0] < hcfBase[2] && baseArray[2] < hcfBase[1]) {
								mcqAllObj = mcqAllObj.concat([
											expo(hcfBase[0], hcfPower[0]) + "\\times" + expo(hcfBase[2], wrongPowerArray[0][2]) + "\\times" + expo(hcfBase[1], wrongPowerArray[0][1]),
											expo(hcfBase[0], hcfPower[0]) + "\\times" + expo(hcfBase[2], wrongPowerArray[1][2]) + "\\times" + expo(hcfBase[1], wrongPowerArray[1][1]),
											expo(hcfBase[0], wrongPowerArray[0][0]) + "\\times" + expo(hcfBase[2], wrongPowerArray[0][2]) + "\\times" + expo(hcfBase[1], hcfPower[1]),
											expo(hcfBase[0], wrongPowerArray[1][0]) + "\\times" + expo(hcfBase[2], wrongPowerArray[1][2]) + "\\times" + expo(hcfBase[1], hcfPower[1]),
											expo(hcfBase[0], wrongPowerArray[0][0]) + "\\times" + expo(hcfBase[2], hcfPower[2]) + "\\times" + expo(hcfBase[1], wrongPowerArray[0][1]),
											expo(hcfBase[0], wrongPowerArray[1][0]) + "\\times" + expo(hcfBase[2], hcfPower[2]) + "\\times" + expo(hcfBase[1], wrongPowerArray[1][1])
											]);
							} else if (hcfBase[1] < hcfBase[0] && hcfBase[0] < hcfBase[2]) {
								mcqAllObj = mcqAllObj.concat([
											expo(hcfBase[1], wrongPowerArray[0][1]) + "\\times" + expo(hcfBase[0], hcfPower[0]) + "\\times" + expo(hcfBase[2], wrongPowerArray[0][2]),
											expo(hcfBase[1], wrongPowerArray[1][1]) + "\\times" + expo(hcfBase[0], hcfPower[0]) + "\\times" + expo(hcfBase[2], wrongPowerArray[1][2]),
											expo(hcfBase[1], hcfPower[1]) + "\\times" + expo(hcfBase[0], wrongPowerArray[0][0]) + "\\times" + expo(hcfBase[2], wrongPowerArray[0][2]),
											expo(hcfBase[1], hcfPower[1]) + "\\times" + expo(hcfBase[0], wrongPowerArray[1][0]) + "\\times" + expo(hcfBase[2], wrongPowerArray[1][2]),
											expo(hcfBase[1], wrongPowerArray[0][1]) + "\\times" + expo(hcfBase[0], wrongPowerArray[0][0]) + "\\times" + expo(hcfBase[2], hcfPower[2]),
											expo(hcfBase[1], wrongPowerArray[1][1]) + "\\times" + expo(hcfBase[0], wrongPowerArray[1][0]) + "\\times" + expo(hcfBase[2], hcfPower[2])
											]);
							} else if (hcfBase[1] < hcfBase[2] && baseArray[2] < hcfBase[0]) {
								mcqAllObj = mcqAllObj.concat([
											expo(hcfBase[1], wrongPowerArray[0][1]) + "\\times" + expo(hcfBase[2], wrongPowerArray[0][2]) + "\\times" + expo(hcfBase[0], hcfPower[0]),
											expo(hcfBase[1], wrongPowerArray[1][1]) + "\\times" + expo(hcfBase[2], wrongPowerArray[1][2]) + "\\times" + expo(hcfBase[0], hcfPower[0]),
											expo(hcfBase[1], hcfPower[1]) + "\\times" + expo(hcfBase[2], wrongPowerArray[0][2]) + "\\times" + expo(hcfBase[0], wrongPowerArray[0][0]),
											expo(hcfBase[1], hcfPower[1]) + "\\times" + expo(hcfBase[2], wrongPowerArray[1][2]) + "\\times" + expo(hcfBase[0], wrongPowerArray[1][0]),
											expo(hcfBase[1], wrongPowerArray[0][1]) + "\\times" + expo(hcfBase[2], hcfPower[2]) + "\\times" + expo(hcfBase[0], wrongPowerArray[0][0]),
											expo(hcfBase[1], wrongPowerArray[1][1]) + "\\times" + expo(hcfBase[2], hcfPower[2]) + "\\times" + expo(hcfBase[0], wrongPowerArray[1][0])
											]);
							} else if (hcfBase[2] < hcfBase[0] && hcfBase[0] < hcfBase[1]) {
								mcqAllObj = mcqAllObj.concat([
											 expo(hcfBase[2], wrongPowerArray[0][2]) + "\\times" + expo(hcfBase[0], hcfPower[0]) + "\\times" + expo(hcfBase[1], wrongPowerArray[0][1]),
											 expo(hcfBase[2], wrongPowerArray[1][2]) + "\\times" + expo(hcfBase[0], hcfPower[0]) + "\\times" + expo(hcfBase[1], wrongPowerArray[1][1]),
											 expo(hcfBase[2], wrongPowerArray[0][2]) + "\\times" + expo(hcfBase[0], wrongPowerArray[0][0]) + "\\times" + expo(hcfBase[1], hcfPower[1]),
											 expo(hcfBase[2], wrongPowerArray[1][2]) + "\\times" + expo(hcfBase[0], wrongPowerArray[1][0]) + "\\times" + expo(hcfBase[1], hcfPower[1]),
											 expo(hcfBase[2], hcfPower[2]) + "\\times" + expo(hcfBase[0], wrongPowerArray[0][0]) + "\\times" + expo(hcfBase[1], wrongPowerArray[0][1]),
											 expo(hcfBase[2], hcfPower[2]) + "\\times" + expo(hcfBase[0], wrongPowerArray[1][0]) + "\\times" + expo(hcfBase[1], wrongPowerArray[1][1])
											]);
							} else if (hcfBase[2] < hcfBase[1] && hcfBase[1] < hcfBase[0]) {
								mcqAllObj = mcqAllObj.concat([
											 expo(hcfBase[2], wrongPowerArray[0][2]) + "\\times" + expo(hcfBase[1], wrongPowerArray[0][1]) + "\\times" + expo(hcfBase[0], hcfPower[0]),
											 expo(hcfBase[2], wrongPowerArray[1][2]) + "\\times" + expo(hcfBase[1], wrongPowerArray[1][1]) + "\\times" + expo(hcfBase[0], hcfPower[0]),
											 expo(hcfBase[2], wrongPowerArray[0][2]) + "\\times" + expo(hcfBase[1], hcfPower[1]) + "\\times" + expo(hcfBase[0], wrongPowerArray[0][0]),
											 expo(hcfBase[2], wrongPowerArray[1][2]) + "\\times" + expo(hcfBase[1], hcfPower[1]) + "\\times" + expo(hcfBase[0], wrongPowerArray[1][0]),
											 expo(hcfBase[2], hcfPower[2]) + "\\times" + expo(hcfBase[1], wrongPowerArray[0][1]) + "\\times" + expo(hcfBase[0], wrongPowerArray[0][0]),
											 expo(hcfBase[2], hcfPower[2]) + "\\times" + expo(hcfBase[1], wrongPowerArray[1][1]) + "\\times" + expo(hcfBase[0], wrongPowerArray[1][0])
											]);
							}

							break;

						case q1 < 92:
							mcqAllObj = [1,
										expo(hcfBase[0], hcfPower[0]),
										expo(hcfBase[1], hcfPower[1]),
										expo(hcfBase[0], wrongPowerArray[0][0]),
										expo(hcfBase[1], wrongPowerArray[0][1]),
										expo(hcfBase[0], wrongPowerArray[1][0]),
										expo(hcfBase[1], wrongPowerArray[1][1]),
										expo(baseArray[2], wrongPowerArray[0][2]),
										expo(baseArray[2], wrongPowerArray[1][2]),
										expo(baseArray[3], wrongPowerArray[0][2]),
										expo(baseArray[3], wrongPowerArray[1][2])];
							if (baseArray[0] < baseArray[1]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][1]),
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[1], wrongPowerArray[1][1]),
											expo(baseArray[0], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][1]),
											expo(baseArray[0], wrongPowerArray[1][0]) + "\\times" + expo(baseArray[1], wrongPowerArray[1][1])
											]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[1], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[0], hcfPower[0]),
											expo(baseArray[1], wrongPowerArray[1][1]) + "\\times" + expo(baseArray[0], hcfPower[0]),
											expo(baseArray[1], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[0], wrongPowerArray[0][0]),
											expo(baseArray[1], wrongPowerArray[1][1]) + "\\times" + expo(baseArray[0], wrongPowerArray[1][0])
											]);
							}
							
							if (baseArray[0] < baseArray[2]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[2], wrongPowerArray[0][2]),
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[2], wrongPowerArray[1][2]),
											expo(baseArray[0], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[2], wrongPowerArray[0][2]),
											expo(baseArray[0], wrongPowerArray[1][0]) + "\\times" + expo(baseArray[2], wrongPowerArray[1][2])
											]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[2], wrongPowerArray[0][2]) + "\\times" + expo(baseArray[0], hcfPower[0]),
											expo(baseArray[2], wrongPowerArray[1][2]) + "\\times" + expo(baseArray[0], hcfPower[0]),
											expo(baseArray[2], wrongPowerArray[0][2]) + "\\times" + expo(baseArray[0], wrongPowerArray[0][0]),
											expo(baseArray[2], wrongPowerArray[1][2]) + "\\times" + expo(baseArray[0], wrongPowerArray[1][0])
											]);
							}

							if (baseArray[0] < baseArray[3]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[3], wrongPowerArray[0][2]),
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[3], wrongPowerArray[1][2]),
											expo(baseArray[0], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[3], wrongPowerArray[0][2]),
											expo(baseArray[0], wrongPowerArray[1][0]) + "\\times" + expo(baseArray[3], wrongPowerArray[1][2])
											]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[3], wrongPowerArray[0][2]) + "\\times" + expo(baseArray[0], hcfPower[0]),
											expo(baseArray[3], wrongPowerArray[1][2]) + "\\times" + expo(baseArray[0], hcfPower[0]),
											expo(baseArray[3], wrongPowerArray[0][2]) + "\\times" + expo(baseArray[0], wrongPowerArray[0][0]),
											expo(baseArray[3], wrongPowerArray[1][2]) + "\\times" + expo(baseArray[0], wrongPowerArray[1][0])
											]);
							}

							if (baseArray[1] < baseArray[2]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[1], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[2], wrongPowerArray[0][2]),
											expo(baseArray[1], wrongPowerArray[1][0]) + "\\times" + expo(baseArray[2], wrongPowerArray[1][2])
											]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[2], wrongPowerArray[0][2]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][0]),
											expo(baseArray[2], wrongPowerArray[1][2]) + "\\times" + expo(baseArray[1], wrongPowerArray[1][0])
											]);
							}

							if (baseArray[1] < baseArray[3]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[1], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[3], wrongPowerArray[0][2]),
											expo(baseArray[1], wrongPowerArray[1][0]) + "\\times" + expo(baseArray[3], wrongPowerArray[1][2])
											]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[3], wrongPowerArray[0][2]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][0]),
											expo(baseArray[3], wrongPowerArray[1][2]) + "\\times" + expo(baseArray[1], wrongPowerArray[1][0])
											]);
							}

							if (baseArray[0] < baseArray[1] && baseArray[1] < baseArray[2]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[2], wrongPowerArray[0][2]),
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[1], wrongPowerArray[1][1]) + "\\times" + expo(baseArray[2], wrongPowerArray[1][2])
											]);
							} else if (baseArray[0] < baseArray[2] && baseArray[2] < baseArray[1]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[2], wrongPowerArray[0][2]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][1]),
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[2], wrongPowerArray[1][2]) + "\\times" + expo(baseArray[1], wrongPowerArray[1][1])
											]);
							} else if (baseArray[1] < baseArray[0] && baseArray[0] < baseArray[2]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[1], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[2], wrongPowerArray[0][2]),
											expo(baseArray[1], wrongPowerArray[1][1]) + "\\times" + expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[2], wrongPowerArray[1][2])
											]);
							} else if (baseArray[1] < baseArray[2] && baseArray[2] < baseArray[0]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[1], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[2], wrongPowerArray[0][2]) + "\\times" + expo(baseArray[0], hcfPower[0]),
											expo(baseArray[1], wrongPowerArray[1][1]) + "\\times" + expo(baseArray[2], wrongPowerArray[1][2]) + "\\times" + expo(baseArray[0], hcfPower[0])
											]);
							} else if (baseArray[2] < baseArray[0] && baseArray[0] < baseArray[1]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[2], wrongPowerArray[0][2]) + "\\times" + expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][1]),
											expo(baseArray[2], wrongPowerArray[1][2]) + "\\times" + expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[1], wrongPowerArray[1][1])
											]);
							} else if (baseArray[2] < baseArray[1] && baseArray[1] < baseArray[0]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[2], wrongPowerArray[0][2]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[0], hcfPower[0]),
											expo(baseArray[2], wrongPowerArray[1][2]) + "\\times" + expo(baseArray[1], wrongPowerArray[1][1]) + "\\times" + expo(baseArray[0], hcfPower[0])
											]);
							}
							break;

						case q1 < 94:
							mcqAllObj = [expo(baseArray[0], wrongPowerArray[0][0]),
										expo(baseArray[1], wrongPowerArray[0][1]),
										expo(baseArray[1], wrongPowerArray[1][1]),
										expo(baseArray[2], wrongPowerArray[0][2]),
										expo(baseArray[2], wrongPowerArray[1][2]),
										expo(baseArray[3], wrongPowerArray[0][1]),
										expo(baseArray[3], wrongPowerArray[1][1]),
										expo(baseArray[4], wrongPowerArray[0][2]),
										expo(baseArray[4], wrongPowerArray[1][2])];

							if (baseArray[0] < baseArray[1]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][1])]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[1], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[0], wrongPowerArray[0][0])]);
							}

							if (baseArray[0] < baseArray[2]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[2], wrongPowerArray[0][2])]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[2], wrongPowerArray[0][2]) + "\\times" + expo(baseArray[0], wrongPowerArray[0][0])]);
							}

							if (baseArray[0] < baseArray[3]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[3], wrongPowerArray[0][1])]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[3], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[0], wrongPowerArray[0][0])]);
							}
							
							if (baseArray[0] < baseArray[4]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[4], wrongPowerArray[0][2])]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[4], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[0], wrongPowerArray[0][0])]);
							}

							if (baseArray[1] < baseArray[2]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[1], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[2], wrongPowerArray[0][2])]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[2], wrongPowerArray[0][2]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][1])]);
							}

							if (baseArray[3] < baseArray[4]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[3], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[4], wrongPowerArray[0][2])]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[4], wrongPowerArray[0][2]) + "\\times" + expo(baseArray[3], wrongPowerArray[0][1])]);
							}

							break;
					}

					// random 4 wrong answers
					let mcqAllObjPos = [];
					while (mcqAllObjPos.length < 4) {
						r = Math.floor(Math.random() * mcqAllObj.length);

						if (mcqAllObjPos.indexOf(r) === -1) {
							mcqAllObjPos.push(r);
						}
					}

					// map for mcq mod
					for (let j = 0; j < 4; j++) {
						mcqMod.push(mcqAllObj[mcqAllObjPos[j]]);
					}
				} else if (q1 < 100) {
					// 5) 6% 3x
					// B) 2^2 x 3^3 x 5^5, 2^3 x 3^2 x 5^4, 2^4 x 3^4 x 5^3
					// i) 2% 3 same base
					// ii) 2% 2 same base
					// iii) 2% 1 same base
					let queTemp1, queTemp2, queTemp3;
					let ansTemp;
					let baseMulti = 3;
					let baseChoice = 3;
					let hcfBaseNum;
					let baseTotalNum;
					let baseArray = [];
					let powerArray = [];
					let wrongPowerArray = [];
					let hcfBase = [];
					let hcfPower = [];
					let hcfPowerTemp;
					let primeNum = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29];
					let primeChoicePos = [];
					let r, j, k, l;

					switch(true) {
						case q1 < 96:
							// generate 3 same base
							hcfBaseNum = 3;
							baseTotalNum = baseChoice * baseMulti - baseChoice * hcfBaseNum + hcfBaseNum;
							break;

						case q1 < 98:
							// generate 2 same base + 2 different base
							hcfBaseNum = 2;
							baseTotalNum = baseChoice * baseMulti - baseChoice * hcfBaseNum + hcfBaseNum;
							break;

						case q1 < 100:
							// generate 1 same base + 4 different base
							hcfBaseNum = 1;
							baseTotalNum = baseChoice * baseMulti - baseChoice * hcfBaseNum + hcfBaseNum;
							break;
					}

					// get all base prime choice position
					while (primeChoicePos.length < baseTotalNum) {
						r = Math.floor(Math.random() * 10);
						if (primeChoicePos.indexOf(r) === -1) {
							primeChoicePos.push(r);
						}
					}

					// get prime base number from prime choice position
					for (j = 0; j < baseTotalNum; j++) {
						baseArray.push(primeNum[primeChoicePos[j]]);
					}

					// get hcf base and power
					hcfBase = baseArray.slice(0, hcfBaseNum);

					// get power array
					while (powerArray.length < baseChoice) {
						let powerArrayTemp = [];
						
						// get power child array
						while (powerArrayTemp.length < baseMulti) {
							r = Math.floor(Math.random() * (9 - 1 + 1)) + 1;
							powerArrayTemp.push(r);
						}

						// check match any other child array
						k = 0;
						for (j = 0; j < powerArray.length; j++) {
							if (powerArrayTemp.every(function (element) {
									return powerArray[j].includes(element);
								}) == true) {
								k++;
							}
						}

						// will only add into powerArray if totally no match
						if (k == 0) {
							powerArray.push(powerArrayTemp);
						}
					}				
						
					// get minimum power
					for (j = 0; j < hcfBaseNum; j++){
						hcfPowerTemp = Math.min(powerArray[0][j], powerArray[1][j], powerArray[2][j]);
						hcfPower.push(hcfPowerTemp);
					}

					// add in answer so that wrong answer won't duplicate with correct answer
					wrongPowerArray = [hcfPower];

					// generate 2 sets of wrong power
					while (wrongPowerArray.length < 3) {
						let powerArrayTemp = [];
						
						// get power child array
						while (powerArrayTemp.length < baseMulti) {
							r = Math.floor(Math.random() * (9 - 1 + 1)) + 1;
							powerArrayTemp.push(r);
						}

						// check match any other child array
						k = 0;
						for (j = 0; j < wrongPowerArray.length; j++) {
							if (powerArrayTemp.some(function (element) {
									return wrongPowerArray[j].includes(element);
								}) == true) {
								k++;
							}
						}

						// will only add into wrongPowerArray if totally no match
						if (k == 0) {
							wrongPowerArray.push(powerArrayTemp);
						}
					}

					// remove answer and left with all wrong power
					wrongPowerArray.splice(0, 1);

					// expo function for type as string;
					function expo(a, b) {
						if (b == 1) {
							return a;
						} else {
							return a + "^" + b;
						}
					}

					// generate question
					// baseChoice -> baseMulti -> basearray -> power array
					switch (true) {
						case q1 < 96:
							for (j = 0; j < baseChoice; j++) {
								for (k = 0; k < baseMulti; k++) {
									// get index form
									queTemp1 = expo(baseArray[k], powerArray[j][k]);

									if (k == 0) {
										queTemp2 = queTemp1;
									} else if (k == 1) {
										//sort
										if (baseArray[k] < baseArray[k - 1]) {
											queTemp2 = queTemp1 + "\\times" + queTemp2;
										} else {
											queTemp2 = queTemp2 + "\\times" + queTemp1;
										}
									} else if (k == 2) {
										// sort
										if (baseArray[k] < baseArray[k - 1] && baseArray[k] < baseArray[k - 2]) {
											queTemp2 = queTemp1 + "\\times" + queTemp2;
										} else if (baseArray[k] > baseArray[k - 1] && baseArray[k] > baseArray[k - 2]) {
											queTemp2 = queTemp2 + "\\times" + queTemp1;
										} else {
											queTemp2 = queTemp2.slice(0, queTemp2.indexOf("\\")).
													concat("\\times").concat(queTemp1).
													concat("\\times").concat(queTemp2.slice(queTemp2.indexOf("\\") + 6));
										}
									}
								}

								// not first then need to have comma (,)
								if (j == 0) {
									que = queTemp2;
								} else {
									que = que + ", " + queTemp2;
								}
							}
							break;

						case q1 < 98:
							for (j = 0; j < baseChoice; j++) {
								for (k = 0; k < baseMulti; k++) {
									// get index form
									// special treatment for 4th number
									if (k == 2 && j == 1) {
										l = 3;
									} else {
										l = k;
									}

									queTemp1 = expo(baseArray[l], powerArray[j][k]);

									if (k == 0) {
										queTemp2 = queTemp1;
									} else if (k == 1) {
										//sort
										if (baseArray[k] < baseArray[k - 1]) {
											queTemp2 = queTemp1 + "\\times" + queTemp2;
										} else {
											queTemp2 = queTemp2 + "\\times" + queTemp1;
										}
									} else if (k == 2) {
										// sort
										if (baseArray[l] < baseArray[k - 1] && baseArray[l] < baseArray[k - 2]) {
											queTemp2 = queTemp1 + "\\times" + queTemp2;
										} else if (baseArray[l] > baseArray[k - 1] && baseArray[l] > baseArray[k - 2]) {
											queTemp2 = queTemp2 + "\\times" + queTemp1;
										} else {
											queTemp2 = queTemp2.slice(0, queTemp2.indexOf("\\")).
													concat("\\times").concat(queTemp1).
													concat("\\times").concat(queTemp2.slice(queTemp2.indexOf("\\") + 6));
										}
									}
								}

								// not first then need to have comma (,)
								if (j == 0) {
									que = queTemp2;
								} else {
									que = que + ", " + queTemp2;
								}
							}
							break;

						case q1 < 100:
							for (j = 0; j < baseChoice; j++) {
								for (k = 0; k < baseMulti; k++) {
									// get index form
									if (k == 0) {
										l = 0;
									} else {
										l = 2 * j + k;
									}
									queTemp1 = expo(baseArray[l], powerArray[j][k]);

									if (k == 0) {
										queTemp2 = queTemp1;
									} else if (k == 1) {
										//sort
										if (baseArray[2 * j + k] < baseArray[k - 1]) {
											queTemp2 = queTemp1 + "\\times" + queTemp2;
										} else {
											queTemp2 = queTemp2 + "\\times" + queTemp1;
										}
									} else if (k == 2) {
										// sort
										if (baseArray[l] < baseArray[2 * j + k - 1] && baseArray[l] < baseArray[k - 2]) {
											queTemp2 = queTemp1 + "\\times" + queTemp2;
										} else if (baseArray[l] > baseArray[2 * j + k - 1] && baseArray[l] > baseArray[k - 2]) {
											queTemp2 = queTemp2 + "\\times" + queTemp1;
										} else {
											queTemp2 = queTemp2.slice(0, queTemp2.indexOf("\\")).
													concat("\\times").concat(queTemp1).
													concat("\\times").concat(queTemp2.slice(queTemp2.indexOf("\\") + 6));
										}
									}
								}

								// not first then need to have comma (,)
								if (j == 0) {
									que = queTemp2;
								} else {
									que = que + ", " + queTemp2;
								}
							}
							break;
					}
					
					// generate answer
					ans = 1;
					for (k = 0; k < hcfBaseNum; k++) {
						// get index form
						ansTemp = expo(hcfBase[k], hcfPower[k]);	
					
						// not first then need to have times (x)
						if (k == 0) {
							ans = ansTemp;
						} else if (k == 1) {
							// sort
							if (baseArray[k] < baseArray[k - 1]) {
								ans = ansTemp + "\\times" + ans;
							} else {
								ans = ans + "\\times" + ansTemp;
							}
						} else if (k == 2) {
							// sort
							if (baseArray[k] < baseArray[k - 1] && baseArray[k] < baseArray[k - 2]) {
								ans = ansTemp + "\\times" + ans;
							} else if (baseArray[k] > baseArray[k - 1] && baseArray[k] > baseArray[k - 2]) {
								ans = ans + "\\times" + ansTemp;
							} else {
								ans = ans.slice(0, ans.indexOf("\\")).
										concat("\\times").concat(ansTemp).
										concat("\\times").concat(ans.slice(ans.indexOf("\\") + 6));
							}
						}
					}

					// all wrong choices
					let mcqAllObj;
					switch (true) {
						case q1 < 96:
							mcqAllObj = [1,
										expo(hcfBase[0], hcfPower[0]),
										expo(hcfBase[1], hcfPower[1]),
										expo(hcfBase[2], hcfPower[2]),
										expo(hcfBase[0], wrongPowerArray[0][0]),
										expo(hcfBase[1], wrongPowerArray[0][1]),
										expo(hcfBase[2], wrongPowerArray[0][2]),
										expo(hcfBase[0], wrongPowerArray[1][0]),
										expo(hcfBase[1], wrongPowerArray[1][1]),
										expo(hcfBase[2], wrongPowerArray[1][2])];

							if (hcfBase[0] < hcfBase[1]) {
								mcqAllObj = mcqAllObj.concat([
											expo(hcfBase[0], hcfPower[0]) + "\\times" + expo(hcfBase[1], wrongPowerArray[0][1]),
											expo(hcfBase[0], hcfPower[0]) + "\\times" + expo(hcfBase[1], wrongPowerArray[1][1]),
											expo(hcfBase[0], wrongPowerArray[0][0]) + "\\times" + expo(hcfBase[1], hcfPower[1]),
											expo(hcfBase[0], wrongPowerArray[1][0]) + "\\times" + expo(hcfBase[1], hcfPower[1]),
											expo(hcfBase[0], wrongPowerArray[0][0]) + "\\times" + expo(hcfBase[1], wrongPowerArray[0][1]),
											expo(hcfBase[0], wrongPowerArray[1][0]) + "\\times" + expo(hcfBase[1], wrongPowerArray[1][1])
											]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(hcfBase[1], wrongPowerArray[0][1]) + "\\times" + expo(hcfBase[0], hcfPower[0]),
											expo(hcfBase[1], wrongPowerArray[1][1]) + "\\times" + expo(hcfBase[0], hcfPower[0]),
											expo(hcfBase[1], hcfPower[1]) + "\\times" + expo(hcfBase[0], wrongPowerArray[0][0]),
											expo(hcfBase[1], hcfPower[1]) + "\\times" + expo(hcfBase[0], wrongPowerArray[1][0]),
											expo(hcfBase[1], wrongPowerArray[0][1]) + "\\times" + expo(hcfBase[0], wrongPowerArray[0][0]),
											expo(hcfBase[1], wrongPowerArray[1][1]) + "\\times" + expo(hcfBase[0], wrongPowerArray[1][0])
											]);
							}

							if (hcfBase[0] < hcfBase[2]) {
								mcqAllObj = mcqAllObj.concat([
											expo(hcfBase[0], hcfPower[0]) + "\\times" + expo(hcfBase[2], wrongPowerArray[0][2]),
											expo(hcfBase[0], hcfPower[0]) + "\\times" + expo(hcfBase[2], wrongPowerArray[1][2]),
											expo(hcfBase[0], wrongPowerArray[0][0]) + "\\times" + expo(hcfBase[2], hcfPower[2]),
											expo(hcfBase[0], wrongPowerArray[1][0]) + "\\times" + expo(hcfBase[2], hcfPower[2]),
											expo(hcfBase[0], wrongPowerArray[0][0]) + "\\times" + expo(hcfBase[2], wrongPowerArray[0][2]),
											expo(hcfBase[0], wrongPowerArray[1][0]) + "\\times" + expo(hcfBase[2], wrongPowerArray[1][2])
											]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(hcfBase[2], wrongPowerArray[0][2]) + "\\times" + expo(hcfBase[0], hcfPower[0]),
											expo(hcfBase[2], wrongPowerArray[1][2]) + "\\times" + expo(hcfBase[0], hcfPower[0]),
											expo(hcfBase[2], hcfPower[2]) + "\\times" + expo(hcfBase[0], wrongPowerArray[0][0]),
											expo(hcfBase[2], hcfPower[2]) + "\\times" + expo(hcfBase[0], wrongPowerArray[1][0]),
											expo(hcfBase[2], wrongPowerArray[0][2]) + "\\times" + expo(hcfBase[0], wrongPowerArray[0][0]),
											expo(hcfBase[2], wrongPowerArray[1][2]) + "\\times" + expo(hcfBase[0], wrongPowerArray[1][0])
											]);
							}

							if (hcfBase[1] < hcfBase[2]) {
								mcqAllObj = mcqAllObj.concat([
											expo(hcfBase[1], hcfPower[1]) + "\\times" + expo(hcfBase[2], wrongPowerArray[0][2]),
											expo(hcfBase[1], hcfPower[1]) + "\\times" + expo(hcfBase[2], wrongPowerArray[1][2]),
											expo(hcfBase[1], wrongPowerArray[0][1]) + "\\times" + expo(hcfBase[2], hcfPower[2]),
											expo(hcfBase[1], wrongPowerArray[1][1]) + "\\times" + expo(hcfBase[2], hcfPower[2]),
											expo(hcfBase[1], wrongPowerArray[0][1]) + "\\times" + expo(hcfBase[2], wrongPowerArray[0][2]),
											expo(hcfBase[1], wrongPowerArray[1][1]) + "\\times" + expo(hcfBase[2], wrongPowerArray[1][2])
											]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(hcfBase[2], wrongPowerArray[0][2]) + "\\times" + expo(hcfBase[1], hcfPower[1]),
											expo(hcfBase[2], wrongPowerArray[1][2]) + "\\times" + expo(hcfBase[1], hcfPower[1]),
											expo(hcfBase[2], hcfPower[2]) + "\\times" + expo(hcfBase[1], wrongPowerArray[0][1]),
											expo(hcfBase[2], hcfPower[2]) + "\\times" + expo(hcfBase[1], wrongPowerArray[1][1]),
											expo(hcfBase[2], wrongPowerArray[0][2]) + "\\times" + expo(hcfBase[1], wrongPowerArray[0][1]),
											expo(hcfBase[2], wrongPowerArray[1][2]) + "\\times" + expo(hcfBase[1], wrongPowerArray[1][1])
											]);
							}

							if (hcfBase[0] < hcfBase[1] && hcfBase[1] < hcfBase[2]) {
								mcqAllObj = mcqAllObj.concat([
											expo(hcfBase[0], hcfPower[0]) + "\\times" + expo(hcfBase[1], wrongPowerArray[0][1]) + "\\times" + expo(hcfBase[2], wrongPowerArray[0][2]),
											expo(hcfBase[0], hcfPower[0]) + "\\times" + expo(hcfBase[1], wrongPowerArray[1][1]) + "\\times" + expo(hcfBase[2], wrongPowerArray[1][2]),
											expo(hcfBase[0], wrongPowerArray[0][0]) + "\\times" + expo(hcfBase[1], hcfPower[1]) + "\\times" + expo(hcfBase[2], wrongPowerArray[0][2]),
											expo(hcfBase[0], wrongPowerArray[1][0]) + "\\times" + expo(hcfBase[1], hcfPower[1]) + "\\times" + expo(hcfBase[2], wrongPowerArray[1][2]),
											expo(hcfBase[0], wrongPowerArray[0][0]) + "\\times" + expo(hcfBase[1], wrongPowerArray[0][1]) + "\\times" + expo(hcfBase[2], hcfPower[2]),
											expo(hcfBase[0], wrongPowerArray[1][0]) + "\\times" + expo(hcfBase[1], wrongPowerArray[1][1]) + "\\times" + expo(hcfBase[2], hcfPower[2])
											]);
							} else if (hcfBase[0] < hcfBase[2] && baseArray[2] < hcfBase[1]) {
								mcqAllObj = mcqAllObj.concat([
											expo(hcfBase[0], hcfPower[0]) + "\\times" + expo(hcfBase[2], wrongPowerArray[0][2]) + "\\times" + expo(hcfBase[1], wrongPowerArray[0][1]),
											expo(hcfBase[0], hcfPower[0]) + "\\times" + expo(hcfBase[2], wrongPowerArray[1][2]) + "\\times" + expo(hcfBase[1], wrongPowerArray[1][1]),
											expo(hcfBase[0], wrongPowerArray[0][0]) + "\\times" + expo(hcfBase[2], wrongPowerArray[0][2]) + "\\times" + expo(hcfBase[1], hcfPower[1]),
											expo(hcfBase[0], wrongPowerArray[1][0]) + "\\times" + expo(hcfBase[2], wrongPowerArray[1][2]) + "\\times" + expo(hcfBase[1], hcfPower[1]),
											expo(hcfBase[0], wrongPowerArray[0][0]) + "\\times" + expo(hcfBase[2], hcfPower[2]) + "\\times" + expo(hcfBase[1], wrongPowerArray[0][1]),
											expo(hcfBase[0], wrongPowerArray[1][0]) + "\\times" + expo(hcfBase[2], hcfPower[2]) + "\\times" + expo(hcfBase[1], wrongPowerArray[1][1])
											]);
							} else if (hcfBase[1] < hcfBase[0] && hcfBase[0] < hcfBase[2]) {
								mcqAllObj = mcqAllObj.concat([
											expo(hcfBase[1], wrongPowerArray[0][1]) + "\\times" + expo(hcfBase[0], hcfPower[0]) + "\\times" + expo(hcfBase[2], wrongPowerArray[0][2]),
											expo(hcfBase[1], wrongPowerArray[1][1]) + "\\times" + expo(hcfBase[0], hcfPower[0]) + "\\times" + expo(hcfBase[2], wrongPowerArray[1][2]),
											expo(hcfBase[1], hcfPower[1]) + "\\times" + expo(hcfBase[0], wrongPowerArray[0][0]) + "\\times" + expo(hcfBase[2], wrongPowerArray[0][2]),
											expo(hcfBase[1], hcfPower[1]) + "\\times" + expo(hcfBase[0], wrongPowerArray[1][0]) + "\\times" + expo(hcfBase[2], wrongPowerArray[1][2]),
											expo(hcfBase[1], wrongPowerArray[0][1]) + "\\times" + expo(hcfBase[0], wrongPowerArray[0][0]) + "\\times" + expo(hcfBase[2], hcfPower[2]),
											expo(hcfBase[1], wrongPowerArray[1][1]) + "\\times" + expo(hcfBase[0], wrongPowerArray[1][0]) + "\\times" + expo(hcfBase[2], hcfPower[2])
											]);
							} else if (hcfBase[1] < hcfBase[2] && baseArray[2] < hcfBase[0]) {
								mcqAllObj = mcqAllObj.concat([
											expo(hcfBase[1], wrongPowerArray[0][1]) + "\\times" + expo(hcfBase[2], wrongPowerArray[0][2]) + "\\times" + expo(hcfBase[0], hcfPower[0]),
											expo(hcfBase[1], wrongPowerArray[1][1]) + "\\times" + expo(hcfBase[2], wrongPowerArray[1][2]) + "\\times" + expo(hcfBase[0], hcfPower[0]),
											expo(hcfBase[1], hcfPower[1]) + "\\times" + expo(hcfBase[2], wrongPowerArray[0][2]) + "\\times" + expo(hcfBase[0], wrongPowerArray[0][0]),
											expo(hcfBase[1], hcfPower[1]) + "\\times" + expo(hcfBase[2], wrongPowerArray[1][2]) + "\\times" + expo(hcfBase[0], wrongPowerArray[1][0]),
											expo(hcfBase[1], wrongPowerArray[0][1]) + "\\times" + expo(hcfBase[2], hcfPower[2]) + "\\times" + expo(hcfBase[0], wrongPowerArray[0][0]),
											expo(hcfBase[1], wrongPowerArray[1][1]) + "\\times" + expo(hcfBase[2], hcfPower[2]) + "\\times" + expo(hcfBase[0], wrongPowerArray[1][0])
											]);
							} else if (hcfBase[2] < hcfBase[0] && hcfBase[0] < hcfBase[1]) {
								mcqAllObj = mcqAllObj.concat([
											 expo(hcfBase[2], wrongPowerArray[0][2]) + "\\times" + expo(hcfBase[0], hcfPower[0]) + "\\times" + expo(hcfBase[1], wrongPowerArray[0][1]),
											 expo(hcfBase[2], wrongPowerArray[1][2]) + "\\times" + expo(hcfBase[0], hcfPower[0]) + "\\times" + expo(hcfBase[1], wrongPowerArray[1][1]),
											 expo(hcfBase[2], wrongPowerArray[0][2]) + "\\times" + expo(hcfBase[0], wrongPowerArray[0][0]) + "\\times" + expo(hcfBase[1], hcfPower[1]),
											 expo(hcfBase[2], wrongPowerArray[1][2]) + "\\times" + expo(hcfBase[0], wrongPowerArray[1][0]) + "\\times" + expo(hcfBase[1], hcfPower[1]),
											 expo(hcfBase[2], hcfPower[2]) + "\\times" + expo(hcfBase[0], wrongPowerArray[0][0]) + "\\times" + expo(hcfBase[1], wrongPowerArray[0][1]),
											 expo(hcfBase[2], hcfPower[2]) + "\\times" + expo(hcfBase[0], wrongPowerArray[1][0]) + "\\times" + expo(hcfBase[1], wrongPowerArray[1][1])
											]);
							} else if (hcfBase[2] < hcfBase[1] && hcfBase[1] < hcfBase[0]) {
								mcqAllObj = mcqAllObj.concat([
											 expo(hcfBase[2], wrongPowerArray[0][2]) + "\\times" + expo(hcfBase[1], wrongPowerArray[0][1]) + "\\times" + expo(hcfBase[0], hcfPower[0]),
											 expo(hcfBase[2], wrongPowerArray[1][2]) + "\\times" + expo(hcfBase[1], wrongPowerArray[1][1]) + "\\times" + expo(hcfBase[0], hcfPower[0]),
											 expo(hcfBase[2], wrongPowerArray[0][2]) + "\\times" + expo(hcfBase[1], hcfPower[1]) + "\\times" + expo(hcfBase[0], wrongPowerArray[0][0]),
											 expo(hcfBase[2], wrongPowerArray[1][2]) + "\\times" + expo(hcfBase[1], hcfPower[1]) + "\\times" + expo(hcfBase[0], wrongPowerArray[1][0]),
											 expo(hcfBase[2], hcfPower[2]) + "\\times" + expo(hcfBase[1], wrongPowerArray[0][1]) + "\\times" + expo(hcfBase[0], wrongPowerArray[0][0]),
											 expo(hcfBase[2], hcfPower[2]) + "\\times" + expo(hcfBase[1], wrongPowerArray[1][1]) + "\\times" + expo(hcfBase[0], wrongPowerArray[1][0])
											]);
							}

							break;

						case q1 < 98:
							mcqAllObj = [1,
										expo(hcfBase[0], hcfPower[0]),
										expo(hcfBase[1], hcfPower[1]),
										expo(hcfBase[0], wrongPowerArray[0][0]),
										expo(hcfBase[1], wrongPowerArray[0][1]),
										expo(hcfBase[0], wrongPowerArray[1][0]),
										expo(hcfBase[1], wrongPowerArray[1][1]),
										expo(baseArray[2], wrongPowerArray[0][2]),
										expo(baseArray[2], wrongPowerArray[1][2]),
										expo(baseArray[3], wrongPowerArray[0][2]),
										expo(baseArray[3], wrongPowerArray[1][2]),
										expo(baseArray[4], wrongPowerArray[0][2]),
										expo(baseArray[4], wrongPowerArray[1][2])];
							if (baseArray[0] < baseArray[1]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][1]),
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[1], wrongPowerArray[1][1]),
											expo(baseArray[0], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][1]),
											expo(baseArray[0], wrongPowerArray[1][0]) + "\\times" + expo(baseArray[1], wrongPowerArray[1][1])
											]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[1], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[0], hcfPower[0]),
											expo(baseArray[1], wrongPowerArray[1][1]) + "\\times" + expo(baseArray[0], hcfPower[0]),
											expo(baseArray[1], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[0], wrongPowerArray[0][0]),
											expo(baseArray[1], wrongPowerArray[1][1]) + "\\times" + expo(baseArray[0], wrongPowerArray[1][0])
											]);
							}
							
							if (baseArray[0] < baseArray[2]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[2], wrongPowerArray[0][2]),
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[2], wrongPowerArray[1][2]),
											expo(baseArray[0], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[2], wrongPowerArray[0][2]),
											expo(baseArray[0], wrongPowerArray[1][0]) + "\\times" + expo(baseArray[2], wrongPowerArray[1][2])
											]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[2], wrongPowerArray[0][2]) + "\\times" + expo(baseArray[0], hcfPower[0]),
											expo(baseArray[2], wrongPowerArray[1][2]) + "\\times" + expo(baseArray[0], hcfPower[0]),
											expo(baseArray[2], wrongPowerArray[0][2]) + "\\times" + expo(baseArray[0], wrongPowerArray[0][0]),
											expo(baseArray[2], wrongPowerArray[1][2]) + "\\times" + expo(baseArray[0], wrongPowerArray[1][0])
											]);
							}

							if (baseArray[0] < baseArray[3]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[3], wrongPowerArray[0][2]),
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[3], wrongPowerArray[1][2]),
											expo(baseArray[0], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[3], wrongPowerArray[0][2]),
											expo(baseArray[0], wrongPowerArray[1][0]) + "\\times" + expo(baseArray[3], wrongPowerArray[1][2])
											]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[3], wrongPowerArray[0][2]) + "\\times" + expo(baseArray[0], hcfPower[0]),
											expo(baseArray[3], wrongPowerArray[1][2]) + "\\times" + expo(baseArray[0], hcfPower[0]),
											expo(baseArray[3], wrongPowerArray[0][2]) + "\\times" + expo(baseArray[0], wrongPowerArray[0][0]),
											expo(baseArray[3], wrongPowerArray[1][2]) + "\\times" + expo(baseArray[0], wrongPowerArray[1][0])
											]);
							}

							if (baseArray[0] < baseArray[4]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[4], wrongPowerArray[0][2]),
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[4], wrongPowerArray[1][2]),
											expo(baseArray[0], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[4], wrongPowerArray[0][2]),
											expo(baseArray[0], wrongPowerArray[1][0]) + "\\times" + expo(baseArray[4], wrongPowerArray[1][2])
											]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[4], wrongPowerArray[0][2]) + "\\times" + expo(baseArray[0], hcfPower[0]),
											expo(baseArray[4], wrongPowerArray[1][2]) + "\\times" + expo(baseArray[0], hcfPower[0]),
											expo(baseArray[4], wrongPowerArray[0][2]) + "\\times" + expo(baseArray[0], wrongPowerArray[0][0]),
											expo(baseArray[4], wrongPowerArray[1][2]) + "\\times" + expo(baseArray[0], wrongPowerArray[1][0])
											]);
							}

							if (baseArray[1] < baseArray[2]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[1], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[2], wrongPowerArray[0][2]),
											expo(baseArray[1], wrongPowerArray[1][0]) + "\\times" + expo(baseArray[2], wrongPowerArray[1][2])
											]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[2], wrongPowerArray[0][2]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][0]),
											expo(baseArray[2], wrongPowerArray[1][2]) + "\\times" + expo(baseArray[1], wrongPowerArray[1][0])
											]);
							}

							if (baseArray[1] < baseArray[3]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[1], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[3], wrongPowerArray[0][2]),
											expo(baseArray[1], wrongPowerArray[1][0]) + "\\times" + expo(baseArray[3], wrongPowerArray[1][2])
											]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[3], wrongPowerArray[0][2]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][0]),
											expo(baseArray[3], wrongPowerArray[1][2]) + "\\times" + expo(baseArray[1], wrongPowerArray[1][0])
											]);
							}

							if (baseArray[1] < baseArray[4]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[1], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[4], wrongPowerArray[0][2]),
											expo(baseArray[1], wrongPowerArray[1][0]) + "\\times" + expo(baseArray[4], wrongPowerArray[1][2])
											]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[4], wrongPowerArray[0][2]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][0]),
											expo(baseArray[4], wrongPowerArray[1][2]) + "\\times" + expo(baseArray[1], wrongPowerArray[1][0])
											]);
							}

							if (baseArray[0] < baseArray[1] && baseArray[1] < baseArray[2]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[2], wrongPowerArray[0][2]),
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[1], wrongPowerArray[1][1]) + "\\times" + expo(baseArray[2], wrongPowerArray[1][2])
											]);
							} else if (baseArray[0] < baseArray[2] && baseArray[2] < baseArray[1]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[2], wrongPowerArray[0][2]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][1]),
											expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[2], wrongPowerArray[1][2]) + "\\times" + expo(baseArray[1], wrongPowerArray[1][1])
											]);
							} else if (baseArray[1] < baseArray[0] && baseArray[0] < baseArray[2]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[1], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[2], wrongPowerArray[0][2]),
											expo(baseArray[1], wrongPowerArray[1][1]) + "\\times" + expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[2], wrongPowerArray[1][2])
											]);
							} else if (baseArray[1] < baseArray[2] && baseArray[2] < baseArray[0]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[1], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[2], wrongPowerArray[0][2]) + "\\times" + expo(baseArray[0], hcfPower[0]),
											expo(baseArray[1], wrongPowerArray[1][1]) + "\\times" + expo(baseArray[2], wrongPowerArray[1][2]) + "\\times" + expo(baseArray[0], hcfPower[0])
											]);
							} else if (baseArray[2] < baseArray[0] && baseArray[0] < baseArray[1]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[2], wrongPowerArray[0][2]) + "\\times" + expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][1]),
											expo(baseArray[2], wrongPowerArray[1][2]) + "\\times" + expo(baseArray[0], hcfPower[0]) + "\\times" + expo(baseArray[1], wrongPowerArray[1][1])
											]);
							} else if (baseArray[2] < baseArray[1] && baseArray[1] < baseArray[0]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[2], wrongPowerArray[0][2]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[0], hcfPower[0]),
											expo(baseArray[2], wrongPowerArray[1][2]) + "\\times" + expo(baseArray[1], wrongPowerArray[1][1]) + "\\times" + expo(baseArray[0], hcfPower[0])
											]);
							}
							break;

						case q1 < 100:
							mcqAllObj = [expo(baseArray[0], wrongPowerArray[0][0]),
										expo(baseArray[1], wrongPowerArray[0][1]),
										expo(baseArray[1], wrongPowerArray[1][1]),
										expo(baseArray[2], wrongPowerArray[0][2]),
										expo(baseArray[2], wrongPowerArray[1][2]),
										expo(baseArray[3], wrongPowerArray[0][1]),
										expo(baseArray[3], wrongPowerArray[1][1]),
										expo(baseArray[4], wrongPowerArray[0][2]),
										expo(baseArray[4], wrongPowerArray[1][2]),
										expo(baseArray[5], wrongPowerArray[0][1]),
										expo(baseArray[5], wrongPowerArray[1][1]),
										expo(baseArray[6], wrongPowerArray[0][2]),
										expo(baseArray[6], wrongPowerArray[1][2])];

							if (baseArray[0] < baseArray[1]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][1])]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[1], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[0], wrongPowerArray[0][0])]);
							}

							if (baseArray[0] < baseArray[2]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[2], wrongPowerArray[0][2])]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[2], wrongPowerArray[0][2]) + "\\times" + expo(baseArray[0], wrongPowerArray[0][0])]);
							}

							if (baseArray[0] < baseArray[3]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[3], wrongPowerArray[0][1])]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[3], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[0], wrongPowerArray[0][0])]);
							}
							
							if (baseArray[0] < baseArray[4]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[4], wrongPowerArray[0][2])]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[4], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[0], wrongPowerArray[0][0])]);
							}

							if (baseArray[0] < baseArray[5]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[5], wrongPowerArray[0][1])]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[5], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[0], wrongPowerArray[0][0])]);
							}
							
							if (baseArray[0] < baseArray[6]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[0], wrongPowerArray[0][0]) + "\\times" + expo(baseArray[6], wrongPowerArray[0][2])]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[6], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[0], wrongPowerArray[0][0])]);
							}

							if (baseArray[1] < baseArray[2]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[1], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[2], wrongPowerArray[0][2])]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[2], wrongPowerArray[0][2]) + "\\times" + expo(baseArray[1], wrongPowerArray[0][1])]);
							}

							if (baseArray[3] < baseArray[4]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[3], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[4], wrongPowerArray[0][2])]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[4], wrongPowerArray[0][2]) + "\\times" + expo(baseArray[3], wrongPowerArray[0][1])]);
							}

							if (baseArray[5] < baseArray[6]) {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[5], wrongPowerArray[0][1]) + "\\times" + expo(baseArray[6], wrongPowerArray[0][2])]);
							} else {
								mcqAllObj = mcqAllObj.concat([
											expo(baseArray[6], wrongPowerArray[0][2]) + "\\times" + expo(baseArray[5], wrongPowerArray[0][1])]);
							}

							break;
					}

					// random 4 wrong answers
					let mcqAllObjPos = [];
					while (mcqAllObjPos.length < 4) {
						r = Math.floor(Math.random() * mcqAllObj.length);

						if (mcqAllObjPos.indexOf(r) === -1) {
							mcqAllObjPos.push(r);
						}
					}

					// map for mcq mod
					for (let j = 0; j < 4; j++) {
						mcqMod.push(mcqAllObj[mcqAllObjPos[j]]);
					}
				}

				// randomized answer position
				let ansPos = Math.floor(Math.random() * 5);
				let fullans = ""

				switch (ansPos) {
					case 0:
						fullans = "a";
						break;
					case 1:
						fullans = "b";
						break;
					case 2:
						fullans = "c";
						break;
					case 3:
						fullans = "d";
						break;
					case 4:
						fullans = "e";
						break;
				}

				// generate all choices
				let mcqChoices = mcqMod.slice(0, ansPos);
				let choicesLeft = mcqMod.slice(ansPos);
				mcqChoices = mcqChoices.concat(ans).concat(choicesLeft);
				
				// Code By Suleman
				let object = {
					question: "HCF of \\(" + que + "\\) is?",
					answers:{
						a: "\\(" + String(mcqChoices[0]) + "\\)",
						b: "\\(" + String(mcqChoices[1]) + "\\)",
						c: "\\(" + String(mcqChoices[2]) + "\\)",
						d: "\\(" + String(mcqChoices[3]) + "\\)",
						e: "\\(" + String(mcqChoices[4]) + "\\)"
					},
					correctAnswer: fullans
				}

				// add question into model
				model.push(object);
			}

			//return model;
			return model;
		}

		// Variables
		var quizContainer = document.getElementById('quiz');
		var resultsContainer = document.getElementById('results');
		var submitButton = document.getElementById('submit');
		let model = [];
		var myQuestions = ranModel();

		// Update the count down every 1 second
		document.getElementById("quiz").style.display = "none";
		var x = null;

		// Kick things off
		buildQuiz();

		// Pagination
		const previousButton = document.getElementById("previous");
		const backBtn = document.getElementById("backBtn");
		const retryBtn = document.getElementById("tryBtn");
		const nextButton = document.getElementById("next");
		const slides = document.querySelectorAll(".slide");
		let currentSlide = 0;
		
		// Show the first slide
		showSlide(currentSlide);
		
		// Event listeners
		submitButton.addEventListener('click', showResults);
		previousButton.addEventListener("click", showPreviousSlide);
		nextButton.addEventListener("click", showNextSlide);
		backBtn.addEventListener("click", backToMenu);
		retryBtn.addEventListener("click", trySameQuiz);

		function backToMenu() {
			//location.reload();
			window.parent.postMessage({id:"goBack"},"*");
		}

		function trySameQuiz() {
			location.reload();
		}

	</script>
</html>